# 三相不平衡潮流计算技术说明

## 1. 算法概述

本文档详细描述了基于对称分量法的三相不平衡潮流计算算法实现。该算法能够处理包含不平衡负载、不对称线路参数以及混合连接方式的电力系统，计算各相的电压、电流和功率分布。

## 2. 理论基础

### 2.1 对称分量变换

三相不平衡系统可以通过对称分量变换分解为三个平衡系统：

- **零序分量(0)**: 三相同相位、同幅值的分量
- **正序分量(+)**: 按正常相序(a-b-c)旋转的平衡分量
- **负序分量(-)**: 按反向相序(a-c-b)旋转的平衡分量

#### 2.1.1 变换矩阵

相量到序分量的变换：

![相量到序分量变换](https://latex.codecogs.com/png.latex?\begin{pmatrix}%20X_0%20\\%20X_1%20\\%20X_2%20\end{pmatrix}%20=%20\frac{1}{3}\begin{pmatrix}%201%20&%201%20&%201%20\\%201%20&%20a%20&%20a^2%20\\%201%20&%20a^2%20&%20a%20\end{pmatrix}\begin{pmatrix}%20X_a%20\\%20X_b%20\\%20X_c%20\end{pmatrix})

序分量到相量的变换：

![序分量到相量变换](https://latex.codecogs.com/png.latex?\begin{pmatrix}%20X_a%20\\%20X_b%20\\%20X_c%20\end{pmatrix}%20=%20\begin{pmatrix}%201%20&%201%20&%201%20\\%201%20&%20a^2%20&%20a%20\\%201%20&%20a%20&%20a^2%20\end{pmatrix}\begin{pmatrix}%20X_0%20\\%20X_1%20\\%20X_2%20\end{pmatrix})

其中 a = e^(j2π/3) = -0.5 + j0.866 是旋转因子。

### 2.2 负载模型

算法支持两种负载连接方式：

1. **星形连接(Wye/Y)**: 负载连接在相线和中性线之间
   - 电流计算: I_{abc} = S_{abc}^*/V_{abc}

2. **三角形连接(Delta/Δ)**: 负载连接在相线之间
   - 线-线电压变换矩阵: 
     ```
     V_Δ = [ 1 -1  0;
             0  1 -1;
            -1  0  1] V_{abc}
     ```
   - 线-线电流到线电流变换: 
     ```
     I_{abc} = [ 1  0 -1;
                -1  1  0;
                 0 -1  1] I_Δ
     ```
   - 电流计算: I_Δ = S_Δ^*/V_Δ

## 3. 算法流程详解

### 3.1 初始化阶段

1. **提取对称分量模型**:
   ```julia
   jpc0, jpc1, jpc2 = extratct_jpc_3ph(jpc_3ph)
   ```
   - `jpc0`: 零序网络模型
   - `jpc1`: 正序网络模型
   - `jpc2`: 负序网络模型

2. **构建导纳矩阵**:
   ```julia
   jpc0, jpc1, jpc2, y_0_pu, y_1_pu, y_2_pu, y_0_f, y_1_f, _, y_0_t, y_1_t, _ = get_y_bus(jpc0, jpc1, jpc2)
   ```
   为三个序网络构建节点导纳矩阵和支路导纳矩阵

3. **负载映射**:
   ```julia
   s_abc_delta, s_abc = load_mapping(case, jpc1)
   ```
   将系统中的负载按连接方式分类并映射到对应的母线

4. **初始化电压**:
   ```julia
   v_012_it = vcat([reshape(Vector{ComplexF64}(ppc["busAC"][:, VM] .* exp.(im .* deg2rad.(ppc["busAC"][:, VA]))), 1, nb) for ppc in (jpc0, jpc1, jpc2)]...)
   ```
   使用三个序网络的初始电压构建初始对称分量电压

### 3.2 迭代计算过程

迭代计算直到功率不匹配度小于指定容差或达到最大迭代次数：

```julia
while any(s_mismatch .> outer_tolerance_mva) && Count < max_iteration
    # 计算标幺值功率
    s_abc_pu = -s_abc ./ jpc1["baseMVA"]
    s_abc_delta_pu = -s_abc_delta ./ jpc1["baseMVA"]
    
    # 计算星形连接的电流
    i_abc_it_wye = conj.(s_abc_pu ./ v_abc_it)
    
    # 计算三角形连接的电流
    i_abc_it_delta = i_del_xfmn * conj.(s_abc_delta_pu ./ (v_del_xfmn * v_abc_it))
    
    # 合并电流
    i_abc_it = i_abc_it_wye + i_abc_it_delta
    i012_it = phase_to_sequence(i_abc_it)
    
    # 计算正序功率
    v1_for_s1 = v_012_it[2, :]
    i1_for_s1 = -i012_it[2, :]
    s1 = v1_for_s1 .* conj.(i1_for_s1)
    
    # 更新正序网络的负载功率
    jpc1["busAC"][pq, PD] = real(s1[pq]) * jpc1["baseMVA"]
    jpc1["busAC"][pq, QD] = imag(s1[pq]) * jpc1["baseMVA"]
    
    # 运行正序网络牛顿-拉夫森潮流计算
    jpc1, success, iterations = run_newton_raphson_pf(jpc1, opt)
    
    # 提取内部变量
    internal_vars_jpc1 = get_internal_variables(jpc1)
    Ybus, Yf, Yt = internal_vars_jpc1[:Ybus], internal_vars_jpc1[:Yf], internal_vars_jpc1[:Yt]
    V = internal_vars_jpc1[:V]
    bus, branch, gen = internal_vars_jpc1[:bus], internal_vars_jpc1[:branch], internal_vars_jpc1[:gen]
    
    # 更新潮流结果
    bus, gen, branch = PowerFlow.pfsoln(baseMVA, bus, gen, branch, Ybus, Yf, Yt, V, ref, pv, pq)
    jpc1["busAC"] = bus
    jpc1["genAC"] = gen
    jpc1["branchAC"] = branch
    
    # 计算零序和负序电压
    v0_pu_it = V_from_I(y_0_pu, i0_pu_it)
    v2_pu_it = V_from_I(y_2_pu, i2_pu_it)
    
    # 计算功率不匹配度
    i1_from_v_it = vec(I1_from_V012(v_012_it, y_1_pu))
    s_from_voltage = S_from_VI_elementwise(v1_for_s1, i1_from_v_it)
    v1_pu_it = V1_from_jpc(jpc1)
    v_012_new = combine_X012(v0_pu_it, v1_pu_it, v2_pu_it)
    s_mismatch = abs.(abs.(s1[pq]) .- abs.(s_from_voltage[pq]))
    
    # 更新电压
    v_012_it = v_012_new
    v_abc_it = sequence_to_phase(v_012_it)
    Count += 1
end
```

### 3.3 结果处理

1. **更新序网络结果**:
   ```julia
   bus0, gen0, branch0 = PowerFlow.pfsoln(baseMVA, bus0, gen0, branch0, y_0_pu, y_0_f, y_0_t,
                                vec(v_012_it[1, :]), ref, pv, pq)
   bus1, gen1, branch1 = PowerFlow.pfsoln(baseMVA, bus1, gen1, branch1, y_1_pu, y_1_f, y_1_t,
                                vec(v_012_it[2, :]), ref, pv, pq)
   bus2, gen2, branch2 = PowerFlow.pfsoln(baseMVA, bus2, gen2, branch2, y_1_pu, y_1_f, y_1_t,
                                vec(v_012_it[3, :]), ref, pv, pq)
   ```

2. **计算三相电压结果**:
   ```julia
   get_bus_v_results_3ph(jpc_3ph, jpc0, jpc1, jpc2)
   ```
   - 计算各相电压幅值和相角
   - 计算不平衡度指标 (负序/正序电压比值)

3. **计算三相功率结果**:
   ```julia
   bus_pq = get_p_q_results_3ph(case, jpc_3ph)
   ```
   - 计算各相有功功率和无功功率

4. **计算支路结果**:
   ```julia
   get_branch_results_3ph(jpc_3ph, jpc0, jpc1, jpc2, bus_pq)
   ```
   - 计算支路电流和功率流

## 4. 关键函数实现细节

### 4.1 对称分量变换函数

```julia
function sequence_to_phase(X012)
    a = phase_shift_unit_operator(120)
    asq = phase_shift_unit_operator(-120)

    Tabc = [1 1 1;
            1 asq a;
            1 a asq]
    return Tabc * X012
end

function phase_to_sequence(Xabc)
    a = phase_shift_unit_operator(120)
    asq = phase_shift_unit_operator(-120)  
    T012 = [1 1 1;
        1 a asq;
        1 asq a] ./ 3 
    return T012 * Xabc
end
```

### 4.2 负载映射函数

```julia
function load_mapping(case::JuliaPowerCase, jpc1::JPC)
    params = Dict{String, Any}()    
    phases = ["a", "b", "c"]
    load_types = ["wye", "delta"]
    load_elements = ["loadsAC", "loadsAC_asymm", "gensAC", "asymmetric_sgen"]

    # 获取总线数量
    nb = size(jpc1.busAC, 1)

    for phase in phases
        for typ in load_types
            # 初始化功率数组
            params["S$(phase)$(typ)"] = (jpc1.busAC[:, PD] .+
                                        jpc1.busAC[:, QD] .* 1im) .* 0
            # ... [初始化其他参数] ...
            
            for element in load_elements
                get_elements(params, case, element, phase, typ)
            end
            
            # 映射负载到母线
            if !isempty(params["b$(typ)"])
                # ... [负载映射逻辑] ...
            end
        end
    end
    
    Sabc_del = vcat(transpose(params["Sadelta"]), transpose(params["Sbdelta"]), transpose(params["Scdelta"]))
    Sabc_wye = vcat(transpose(params["Sawye"]), transpose(params["Sbwye"]), transpose(params["Scwye"]))
    return Sabc_del, Sabc_wye
end
```

### 4.3 电压计算函数

```julia
function V_from_I(Y, I)
    # 确保 I 是列向量形式
    I_vec = vec(collect(I))  # 将任何形式的 I 转换为列向量
    
    # 求解线性方程组 Y·V = I
    V = Y \ I_vec
    
    # 返回结果
    return transpose(V)
end
```

### 4.4 功率计算函数

```julia
function S_from_VI_elementwise(v, i)
    return v .* conj(i)
end
```

## 5. 数据结构详解

### 5.1 JPC (Julia Power Case) 结构

```julia
struct JPC
    baseMVA::Float64
    busAC::Matrix{Float64}
    branchAC::Matrix{Float64}
    genAC::Matrix{Float64}
    loadAC::Matrix{Float64}
    success::Bool
    iterationsAC::Int
    # 其他字段...
end
```

### 5.2 JPC_3ph 结构

```julia
struct JPC_3ph
    baseMVA::Float64
    # 零序网络
    busAC_0::Matrix{Float64}
    branchAC_0::Matrix{Float64}
    genAC_0::Matrix{Float64}
    loadAC_0::Matrix{Float64}
    
    # 正序网络
    busAC_1::Matrix{Float64}
    branchAC_1::Matrix{Float64}
    genAC_1::Matrix{Float64}
    loadAC_1::Matrix{Float64}
    
    # 负序网络
    busAC_2::Matrix{Float64}
    branchAC_2::Matrix{Float64}
    genAC_2::Matrix{Float64}
    loadAC_2::Matrix{Float64}
    
    # 结果存储
    res_bus_3ph::Matrix{Float64}
    res_branch_3ph::Matrix{Float64}
    res_gen_3ph::Matrix{Float64}
    res_ext_grid_3ph::DataFrame
    
    # 其他字段...
end
```

### 5.3 母线和支路数据索引常量

```julia
# 母线数据索引
const BUS_I = 1      # 母线编号
const BUS_TYPE = 2   # 母线类型
const PD = 3         # 有功负荷
const QD = 4         # 无功负荷
const GS = 5         # 并联电导
const BS = 6         # 并联电纳
const VM = 8         # 电压幅值
const VA = 9         # 电压相角
const BASE_KV = 10   # 基准电压

# 发电机数据索引
const GEN_BUS = 1    # 发电机连接的母线
const PG = 2         # 有功出力
const QG = 3         # 无功出力
const VG = 6         # 电压设定值
const GEN_STATUS = 8 # 发电机状态

# 支路数据索引
const F_BUS = 1      # 起始母线
const T_BUS = 2      # 终止母线
const BR_STATUS = 11 # 支路状态
const PF = 14        # 起始端有功功率
const QF = 15        # 起始端无功功率
const PT = 16        # 终止端有功功率
const QT = 17        # 终止端无功功率
```

## 6. 算法性能与精度分析

### 6.1 收敛特性

- **收敛判据**: 功率不匹配度 `s_mismatch` 小于指定容差 `outer_tolerance_mva` (默认为 3e-8)
- **收敛速度**: 通常在 5-10 次迭代内收敛
- **最大迭代次数**: 默认为 30 次，可根据系统规模调整

### 6.2 计算精度

- **电压精度**: 通常可达到 1e-6 pu 的精度
- **功率平衡**: 节点功率不平衡通常小于 1e-8 MVA
- **不平衡度计算**: 使用负序/正序电压比值，以百分比表示

### 6.3 计算效率优化

- **稀疏矩阵运算**: 使用稀疏矩阵存储导纳矩阵，提高大型系统的计算效率
- **向量化操作**: 大量使用 Julia 的向量化操作，减少循环次数
- **分组求和优化**: 使用 `sum_by_group` 函数优化按母线分组的功率求和操作

## 7. 应用示例

### 7.1 典型调用流程

```julia
# 创建案例
case = create_test_case()

# 创建三相模型
jpc_3ph = create_3ph_model(case)

# 设置计算选项
opt = Dict(
    "PF" => Dict(
        "PF_TOL" => 1e-8,
        "PF_MAX_IT" => 30,
        "NR_ALG" => "IWAMOTO"
    )
)

# 运行三相潮流计算
gs_eg = 0.0  # 外部电网并联电导
bs_eg = 0.0  # 外部电网并联电纳
result = runupf(case, jpc_3ph, gs_eg, bs_eg, opt)

# 分析结果
analyze_results(result)
```

### 7.2 结果分析

```julia
function analyze_results(jpc_3ph)
    # 提取电压结果
    vm_a = jpc_3ph["res_bus_3ph"][:,RES_3PH_VM_A]
    vm_b = jpc_3ph["res_bus_3ph"][:,RES_3PH_VM_B]
    vm_c = jpc_3ph["res_bus_3ph"][:,RES_3PH_VM_C]
    
    # 计算电压不平衡指标
    v_unbalance = jpc_3ph["res_bus_3ph"][:,RES_3PH_UNBALANCED]
    
    # 提取功率结果
    p_a = jpc_3ph["res_bus_3ph"][:,RES_3PH_PA_MW]
    p_b = jpc_3ph["res_bus_3ph"][:,RES_3PH_PB_MW]
    p_c = jpc_3ph["res_bus_3ph"][:,RES_3PH_PC_MW]
    
    # 分析不平衡度
    println("最大电压不平衡度: $(maximum(v_unbalance))%")
    println("平均电压不平衡度: $(mean(v_unbalance))%")
    
    # 分析相间功率不平衡
    p_imbalance_ab = abs.(p_a - p_b) ./ max.(abs.(p_a), abs.(p_b), 1e-6) * 100
    p_imbalance_bc = abs.(p_b - p_c) ./ max.(abs.(p_b), abs.(p_c), 1e-6) * 100
    p_imbalance_ca = abs.(p_c - p_a) ./ max.(abs.(p_c), abs.(p_a), 1e-6) * 100
    
    println("最大相间功率不平衡度: $(maximum([p_imbalance_ab; p_imbalance_bc; p_imbalance_ca]))%")
end
```

## 8. 技术限制与未来改进

### 8.1 当前限制

1. **零序网络模型**: 当前实现假设零序网络与正序网络具有相同的拓扑结构，但参数不同
2. **非线性负载**: 当前实现主要针对恒定功率负载，对于恒定阻抗和恒定电流负载的支持有限
3. **分布式发电**: 对于具有复杂控制策略的分布式发电的建模有待完善

### 8.2 未来改进方向

1. **改进收敛性**: 引入加速收敛技术，如最优乘子法
2. **增强负载模型**: 支持ZIP负载模型和频率相关负载模型
3. **分布式计算**: 引入并行计算技术，提高大型系统的计算效率
4. **故障分析集成**: 与三相故障分析功能集成

## 9. 算法核心流程图

```
┌─────────────────────────┐
│ 初始化对称分量网络模型  │
└───────────┬─────────────┘
            ▼
┌─────────────────────────┐
│ 构建导纳矩阵            │
└───────────┬─────────────┘
            ▼
┌─────────────────────────┐
│ 负载映射与初始化        │
└───────────┬─────────────┘
            ▼
┌─────────────────────────┐
│ 初始化对称分量电压      │
└───────────┬─────────────┘
            ▼
┌─────────────────────────┐
│ 开始迭代计算            │◄────┐
└───────────┬─────────────┘     │
            ▼                   │
┌─────────────────────────┐     │
│ 计算各相电流            │     │
└───────────┬─────────────┘     │
            ▼                   │
┌─────────────────────────┐     │
│ 相电流转换为序电流      │     │
└───────────┬─────────────┘     │
            ▼                   │
┌─────────────────────────┐     │
│ 计算正序功率            │     │
└───────────┬─────────────┘     │
            ▼                   │
┌─────────────────────────┐     │
│ 更新正序网络负载功率    │     │
└───────────┬─────────────┘     │
            ▼                   │
┌─────────────────────────┐     │
│ 执行正序网络潮流计算    │     │
└───────────┬─────────────┘     │
            ▼                   │
┌─────────────────────────┐     │
│ 计算零序和负序电压      │     │
└───────────┬─────────────┘     │
            ▼                   │
┌─────────────────────────┐     │
│ 计算功率不匹配度        │     │
└───────────┬─────────────┘     │
            ▼                   │
┌─────────────────────────┐     │
│ 更新对称分量电压        │     │
└───────────┬─────────────┘     │
            ▼                   │
┌─────────────────────────┐     │
│ 检查收敛条件            │─────┘
└───────────┬─────────────┘
            ▼
┌─────────────────────────┐
│ 计算最终结果            │
└───────────┬─────────────┘
            ▼
┌─────────────────────────┐
│ 返回三相潮流计算结果    │
└─────────────────────────┘
```

## 10. 参考文献

1. Arrillaga, J., & Watson, N. R. (2001). Computer modelling of electrical power systems (2nd ed.). Wiley.
2. Kersting, W. H. (2012). Distribution system modeling and analysis (3rd ed.). CRC Press.
3. Milano, F. (2010). Power system modelling and scripting. Springer.
4. Zimmerman, R. D., & Murillo-Sánchez, C. E. (2019). MATPOWER user's manual, version 7.0.