<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>时序潮流示例 · 电力系统建模与分析工具集</title><meta name="title" content="时序潮流示例 · 电力系统建模与分析工具集"/><meta property="og:title" content="时序潮流示例 · 电力系统建模与分析工具集"/><meta property="twitter:title" content="时序潮流示例 · 电力系统建模与分析工具集"/><meta name="description" content="Documentation for 电力系统建模与分析工具集."/><meta property="og:description" content="Documentation for 电力系统建模与分析工具集."/><meta property="twitter:description" content="Documentation for 电力系统建模与分析工具集."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">首页</a></li><li><a class="tocitem" href="../getting_started.html">入门指南</a></li><li><span class="tocitem">API参考</span><ul><li><a class="tocitem" href="../api/overview.html">概述</a></li><li><a class="tocitem" href="../api/component_model.html">ComponentModel模块</a></li><li><a class="tocitem" href="../api/power_flow.html">PowerFlow模块</a></li><li><a class="tocitem" href="../api/utils.html">Utils模块</a></li><li><a class="tocitem" href="../api/time_series_power_flow.html">TimeSeriesPowerFlow模块</a></li></ul></li><li><span class="tocitem">函数说明</span><ul><li><a class="tocitem" href="../functions/component_functions.html">组件函数</a></li><li><a class="tocitem" href="../functions/power_flow_functions.html">潮流计算函数</a></li><li><a class="tocitem" href="../functions/utils_functions.html">工具函数</a></li><li><a class="tocitem" href="../functions/time_series_functions.html">时序潮流函数</a></li></ul></li><li><a class="tocitem" href="../main.html">主程序说明</a></li><li><span class="tocitem">示例</span><ul><li><a class="tocitem" href="basic.html">基础示例</a></li><li><a class="tocitem" href="power_flow.html">潮流计算示例</a></li><li class="is-active"><a class="tocitem" href="time_series.html">时序潮流示例</a><ul class="internal"><li><a class="tocitem" href="#基础时间序列潮流计算"><span>基础时间序列潮流计算</span></a></li><li><a class="tocitem" href="#包含可再生能源的时间序列分析"><span>包含可再生能源的时间序列分析</span></a></li><li><a class="tocitem" href="#动态经济调度"><span>动态经济调度</span></a></li><li><a class="tocitem" href="#线性分布潮流"><span>线性分布潮流</span></a></li><li><a class="tocitem" href="#违例分析与可视化"><span>违例分析与可视化</span></a></li><li><a class="tocitem" href="#高级应用"><span>高级应用</span></a></li></ul></li><li><a class="tocitem" href="visualization.html">可视化示例</a></li></ul></li><li><a class="tocitem" href="../development.html">开发指南</a></li><li><a class="tocitem" href="../faq.html">常见问题</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">示例</a></li><li class="is-active"><a href="time_series.html">时序潮流示例</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="time_series.html">时序潮流示例</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Matrixeigs/DistributionPowerFlow" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Matrixeigs/DistributionPowerFlow/blob/master/docs/src/examples/time_series.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="TimeSeriesPowerFlow-模块示例"><a class="docs-heading-anchor" href="#TimeSeriesPowerFlow-模块示例">TimeSeriesPowerFlow 模块示例</a><a id="TimeSeriesPowerFlow-模块示例-1"></a><a class="docs-heading-anchor-permalink" href="#TimeSeriesPowerFlow-模块示例" title="Permalink"></a></h1><p>本文档提供了 TimeSeriesPowerFlow 模块的详细使用示例，展示了时间序列潮流计算、动态调度、可再生能源集成以及结果可视化的应用方法。这些示例旨在帮助用户深入理解 TimeSeriesPowerFlow 模块的核心功能。</p><h2 id="基础时间序列潮流计算"><a class="docs-heading-anchor" href="#基础时间序列潮流计算">基础时间序列潮流计算</a><a id="基础时间序列潮流计算-1"></a><a class="docs-heading-anchor-permalink" href="#基础时间序列潮流计算" title="Permalink"></a></h2><h3 id="加载数据与基本计算"><a class="docs-heading-anchor" href="#加载数据与基本计算">加载数据与基本计算</a><a id="加载数据与基本计算-1"></a><a class="docs-heading-anchor-permalink" href="#加载数据与基本计算" title="Permalink"></a></h3><p>执行基本的时间序列潮流计算：</p><pre><code class="language-julia hljs">using PowerFlow
using TimeSeriesPowerFlow
using Plots

# 加载标准测试系统
case = load_case(&quot;case14.m&quot;)

# 准备24小时负荷数据
# 这里假设load_data.xlsx包含了24小时的负荷曲线数据
load_file = &quot;load_data.xlsx&quot;

# 执行时间序列潮流计算
results = runtdpf(case, load_file)

# 检查计算结果
println(&quot;时间序列潮流计算结果:&quot;)
println(&quot;  时间点数量: $(length(results.time_points))&quot;)
println(&quot;  成功计算的时间点数量: $(sum(results.success))&quot;)

# 查看第一个时间点的结果
if results.success[1]
    first_result = results.bus_results[1]
    println(&quot;第一个时间点:&quot;)
    println(&quot;  总负荷: $(sum(first_result.bus[:, PD])) MW&quot;)
    println(&quot;  总发电: $(sum(first_result.gen[:, PG])) MW&quot;)
    println(&quot;  总损耗: $(sum(first_result.branch[:, PL])) MW&quot;)
end</code></pre><h3 id="结果可视化"><a class="docs-heading-anchor" href="#结果可视化">结果可视化</a><a id="结果可视化-1"></a><a class="docs-heading-anchor-permalink" href="#结果可视化" title="Permalink"></a></h3><p>可视化时间序列潮流计算结果：</p><pre><code class="language-julia hljs"># 提取时间序列数据
time_points = results.time_points
total_load = zeros(length(time_points))
total_gen = zeros(length(time_points))
total_loss = zeros(length(time_points))
min_voltage = zeros(length(time_points))

for t in 1:length(time_points)
    if results.success[t]
        result = results.bus_results[t]
        total_load[t] = sum(result.bus[:, PD])
        total_gen[t] = sum(result.gen[:, PG])
        total_loss[t] = sum(result.branch[:, PL])
        min_voltage[t] = minimum(result.bus[:, VM])
    else
        # 对未收敛的时间点使用NaN
        total_load[t] = NaN
        total_gen[t] = NaN
        total_loss[t] = NaN
        min_voltage[t] = NaN
    end
end

# 绘制负荷曲线
p1 = plot(time_points, total_load,
    title=&quot;24小时负荷曲线&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;总负荷(MW)&quot;,
    marker=:circle,
    label=&quot;总负荷&quot;,
    legend=:topleft)

# 绘制发电曲线
p2 = plot(time_points, total_gen,
    title=&quot;24小时发电曲线&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;总发电(MW)&quot;,
    marker=:circle,
    label=&quot;总发电&quot;,
    legend=:topleft)

# 绘制损耗曲线
p3 = plot(time_points, total_loss,
    title=&quot;24小时系统损耗曲线&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;总损耗(MW)&quot;,
    marker=:circle,
    label=&quot;总损耗&quot;,
    legend=:topleft)

# 绘制最低电压曲线
p4 = plot(time_points, min_voltage,
    title=&quot;24小时最低电压曲线&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;最低电压(pu)&quot;,
    marker=:circle,
    label=&quot;最低电压&quot;,
    legend=:bottomleft)

# 组合图表
plot(p1, p2, p3, p4, layout=(2,2), size=(1000, 800))
savefig(&quot;time_series_results.png&quot;)</code></pre><h3 id="使用内置可视化函数"><a class="docs-heading-anchor" href="#使用内置可视化函数">使用内置可视化函数</a><a id="使用内置可视化函数-1"></a><a class="docs-heading-anchor-permalink" href="#使用内置可视化函数" title="Permalink"></a></h3><p>使用模块提供的内置可视化函数：</p><pre><code class="language-julia hljs"># 使用内置函数绘制电压时间序列
plot_time_day = 1  # 分析第一天的数据
plot_voltage_time_series(results, case, plot_time_day)

# 绘制系统损耗时间序列
plot_losses_time_series(results, case, plot_time_day)

# 绘制特定母线的电压时间序列
bus_id = 5  # 选择特定母线
plot_bus_voltage_time_series(results, case, bus_id, plot_time_day)

# 绘制特定支路的功率流时间序列
branch_idx = 3  # 选择特定支路
plot_branch_flow_time_series(results, case, branch_idx, plot_time_day)</code></pre><h2 id="包含可再生能源的时间序列分析"><a class="docs-heading-anchor" href="#包含可再生能源的时间序列分析">包含可再生能源的时间序列分析</a><a id="包含可再生能源的时间序列分析-1"></a><a class="docs-heading-anchor-permalink" href="#包含可再生能源的时间序列分析" title="Permalink"></a></h2><h3 id="光伏发电集成"><a class="docs-heading-anchor" href="#光伏发电集成">光伏发电集成</a><a id="光伏发电集成-1"></a><a class="docs-heading-anchor-permalink" href="#光伏发电集成" title="Permalink"></a></h3><p>模拟包含光伏发电的时间序列潮流：</p><pre><code class="language-julia hljs"># 准备光照强度数据
# 假设irradiance_data.xlsx包含了24小时的光照强度数据
irradiance_file = &quot;irradiance_data.xlsx&quot;

# 执行包含光照数据的时间序列潮流计算
pv_results = runtdpf(case, load_file, irradiance_file)

# 分析光伏发电输出
# 假设系统中的PV发电机编号为[3, 5]
pv_gen_indices = [3, 5]

# 提取光伏发电时间序列
pv_generation = zeros(length(pv_results.time_points), length(pv_gen_indices))

for t in 1:length(pv_results.time_points)
    if pv_results.success[t]
        for (i, gen_idx) in enumerate(pv_gen_indices)
            pv_generation[t, i] = pv_results.bus_results[t].gen[gen_idx, PG]
        end
    end
end

# 绘制光伏发电曲线
plot(pv_results.time_points, pv_generation,
    title=&quot;光伏发电时间序列&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;发电功率(MW)&quot;,
    label=[&quot;PV发电机 $(pv_gen_indices[i])&quot; for i in 1:length(pv_gen_indices)],
    marker=:circle,
    legend=:topleft)
savefig(&quot;pv_generation.png&quot;)

# 分析光伏渗透率对系统的影响
total_gen_with_pv = zeros(length(pv_results.time_points))
total_loss_with_pv = zeros(length(pv_results.time_points))

for t in 1:length(pv_results.time_points)
    if pv_results.success[t]
        total_gen_with_pv[t] = sum(pv_results.bus_results[t].gen[:, PG])
        total_loss_with_pv[t] = sum(pv_results.bus_results[t].branch[:, PL])
    end
end

# 计算光伏发电占比
pv_penetration = sum(pv_generation, dims=2) ./ total_gen_with_pv * 100

# 绘制光伏渗透率曲线
plot(pv_results.time_points, pv_penetration,
    title=&quot;光伏渗透率时间序列&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;光伏渗透率(%)&quot;,
    marker=:circle,
    legend=false)
savefig(&quot;pv_penetration.png&quot;)</code></pre><h3 id="最大功率点跟踪"><a class="docs-heading-anchor" href="#最大功率点跟踪">最大功率点跟踪</a><a id="最大功率点跟踪-1"></a><a class="docs-heading-anchor-permalink" href="#最大功率点跟踪" title="Permalink"></a></h3><p>模拟光伏发电的最大功率点跟踪：</p><pre><code class="language-julia hljs"># 设置MPPT选项
mppt_opt = Dict(
    &quot;pv_mode&quot; =&gt; &quot;MPPT&quot;,
    &quot;verbose&quot; =&gt; 1
)

# 执行带有MPPT的时间序列潮流计算
mppt_results = runtdpf(case, load_file, irradiance_file, nothing, mppt_opt)

# 比较MPPT模式与默认模式的光伏发电
mppt_generation = zeros(length(mppt_results.time_points), length(pv_gen_indices))

for t in 1:length(mppt_results.time_points)
    if mppt_results.success[t]
        for (i, gen_idx) in enumerate(pv_gen_indices)
            mppt_generation[t, i] = mppt_results.bus_results[t].gen[gen_idx, PG]
        end
    end
end

# 绘制比较图
for i in 1:length(pv_gen_indices)
    plot(pv_results.time_points, [pv_generation[:, i] mppt_generation[:, i]],
        title=&quot;PV发电机 $(pv_gen_indices[i]) 发电比较&quot;,
        xlabel=&quot;时间(小时)&quot;,
        ylabel=&quot;发电功率(MW)&quot;,
        label=[&quot;默认模式&quot; &quot;MPPT模式&quot;],
        marker=:circle,
        legend=:topleft)
    savefig(&quot;pv_mppt_comparison_$(pv_gen_indices[i]).png&quot;)
end</code></pre><h2 id="动态经济调度"><a class="docs-heading-anchor" href="#动态经济调度">动态经济调度</a><a id="动态经济调度-1"></a><a class="docs-heading-anchor-permalink" href="#动态经济调度" title="Permalink"></a></h2><h3 id="基本经济调度"><a class="docs-heading-anchor" href="#基本经济调度">基本经济调度</a><a id="基本经济调度-1"></a><a class="docs-heading-anchor-permalink" href="#基本经济调度" title="Permalink"></a></h3><p>执行基本的动态经济调度：</p><pre><code class="language-julia hljs"># 准备电价数据
# 假设price_data.xlsx包含了24小时的电价数据
price_file = &quot;price_data.xlsx&quot;

# 设置动态调度选项
dispatch_opt = Dict(
    &quot;mode&quot; =&gt; &quot;dynamic_dispatch&quot;,
    &quot;verbose&quot; =&gt; 1
)

# 执行动态经济调度计算
dispatch_results = runtdpf(case, load_file, irradiance_file, price_file, dispatch_opt)

# 分析调度结果
# 提取各发电机的出力曲线
gen_dispatch = zeros(length(dispatch_results.time_points), size(case.gen, 1))
prices = zeros(length(dispatch_results.time_points))

for t in 1:length(dispatch_results.time_points)
    if dispatch_results.success[t]
        for g in 1:size(case.gen, 1)
            gen_dispatch[t, g] = dispatch_results.bus_results[t].gen[g, PG]
        end
        prices[t] = dispatch_results.prices[t]
    end
end

# 绘制发电机出力曲线
plot(dispatch_results.time_points, gen_dispatch,
    title=&quot;发电机经济调度结果&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;发电功率(MW)&quot;,
    label=[&quot;发电机 $g&quot; for g in 1:size(case.gen, 1)],
    legend=:outerright)
savefig(&quot;economic_dispatch.png&quot;)

# 绘制电价曲线
plot(dispatch_results.time_points, prices,
    title=&quot;24小时电价曲线&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;电价($/MWh)&quot;,
    marker=:circle,
    legend=false)
savefig(&quot;price_curve.png&quot;)

# 计算总发电成本
total_cost = sum(prices .* sum(gen_dispatch, dims=2))
println(&quot;总发电成本: $total_cost $&quot;)</code></pre><h3 id="考虑网络约束的经济调度"><a class="docs-heading-anchor" href="#考虑网络约束的经济调度">考虑网络约束的经济调度</a><a id="考虑网络约束的经济调度-1"></a><a class="docs-heading-anchor-permalink" href="#考虑网络约束的经济调度" title="Permalink"></a></h3><p>执行考虑网络约束的经济调度：</p><pre><code class="language-julia hljs"># 设置考虑网络约束的动态调度选项
network_dispatch_opt = Dict(
    &quot;mode&quot; =&gt; &quot;network_constrained_dispatch&quot;,
    &quot;enforce_branch_limits&quot; =&gt; 1,
    &quot;verbose&quot; =&gt; 1
)

# 执行考虑网络约束的动态经济调度
network_results = runtdpf(case, load_file, irradiance_file, price_file, network_dispatch_opt)

# 分析网络约束下的调度结果
network_gen_dispatch = zeros(length(network_results.time_points), size(case.gen, 1))

for t in 1:length(network_results.time_points)
    if network_results.success[t]
        for g in 1:size(case.gen, 1)
            network_gen_dispatch[t, g] = network_results.bus_results[t].gen[g, PG]
        end
    end
end

# 比较有无网络约束的调度结果
for g in 1:size(case.gen, 1)
    plot(dispatch_results.time_points, [gen_dispatch[:, g] network_gen_dispatch[:, g]],
        title=&quot;发电机 $g 调度比较&quot;,
        xlabel=&quot;时间(小时)&quot;,
        ylabel=&quot;发电功率(MW)&quot;,
        label=[&quot;无网络约束&quot; &quot;有网络约束&quot;],
        marker=:circle,
        legend=:topleft)
    savefig(&quot;dispatch_comparison_gen_$g.png&quot;)
end

# 分析网络约束的影响
# 检查是否有支路达到限制
branch_loading = zeros(length(network_results.time_points), size(case.branch, 1))
branch_limits = case.branch[:, RATE_A]

for t in 1:length(network_results.time_points)
    if network_results.success[t]
        for br in 1:size(case.branch, 1)
            if branch_limits[br] &gt; 0  # 只考虑有限制的支路
                branch_loading[t, br] = abs(network_results.bus_results[t].branch[br, PF]) / branch_limits[br] * 100
            end
        end
    end
end

# 找出负载率最高的支路
max_loading = maximum(branch_loading, dims=1)[:]
critical_branches = findall(max_loading .&gt; 90)  # 负载率超过90%的支路

if !isempty(critical_branches)
    println(&quot;关键支路(最大负载率超过90%):&quot;)
    for br in critical_branches
        println(&quot;  支路 $(case.branch[br, F_BUS])-$(case.branch[br, T_BUS]): $(max_loading[br])%&quot;)
    end
    
    # 绘制关键支路的负载率曲线
    plot(network_results.time_points, branch_loading[:, critical_branches],
        title=&quot;关键支路负载率&quot;,
        xlabel=&quot;时间(小时)&quot;,
        ylabel=&quot;负载率(%)&quot;,
        label=[&quot;支路 $(case.branch[br, F_BUS])-$(case.branch[br, T_BUS])&quot; for br in critical_branches],
        legend=:outerright)
    savefig(&quot;critical_branch_loading.png&quot;)
end</code></pre><h2 id="线性分布潮流"><a class="docs-heading-anchor" href="#线性分布潮流">线性分布潮流</a><a id="线性分布潮流-1"></a><a class="docs-heading-anchor-permalink" href="#线性分布潮流" title="Permalink"></a></h2><h3 id="基本线性分布潮流计算"><a class="docs-heading-anchor" href="#基本线性分布潮流计算">基本线性分布潮流计算</a><a id="基本线性分布潮流计算-1"></a><a class="docs-heading-anchor-permalink" href="#基本线性分布潮流计算" title="Permalink"></a></h3><p>执行线性分布潮流计算：</p><pre><code class="language-julia hljs"># 设置线性分布潮流选项
lindist_opt = Dict(
    &quot;pf_alg&quot; =&gt; &quot;LINDISTFLOW&quot;,
    &quot;verbose&quot; =&gt; 1
)

# 执行线性分布潮流计算
lindist_results = runlindistflow(case, load_file)

# 比较线性分布潮流与完整潮流计算的结果
# 提取两种方法的电压结果
voltage_full = zeros(length(results.time_points), size(case.bus, 1))
voltage_lindist = zeros(length(lindist_results.time_points), size(case.bus, 1))

for t in 1:length(results.time_points)
    if results.success[t] &amp;&amp; lindist_results.success[t]
        for b in 1:size(case.bus, 1)
            voltage_full[t, b] = results.bus_results[t].bus[b, VM]
            voltage_lindist[t, b] = lindist_results.bus_results[t].bus[b, VM]
        end
    end
end

# 计算电压误差
voltage_error = abs.(voltage_full - voltage_lindist)
max_error = maximum(voltage_error)
avg_error = mean(voltage_error)

println(&quot;线性分布潮流与完整潮流计算的电压比较:&quot;)
println(&quot;  最大误差: $max_error pu&quot;)
println(&quot;  平均误差: $avg_error pu&quot;)

# 绘制特定母线的电压比较
bus_to_plot = 5  # 选择一个母线进行比较
plot(results.time_points, [voltage_full[:, bus_to_plot] voltage_lindist[:, bus_to_plot]],
    title=&quot;母线 $(case.bus[bus_to_plot, BUS_I]) 电压比较&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;电压幅值(pu)&quot;,
    label=[&quot;完整潮流&quot; &quot;线性分布潮流&quot;],
    marker=:circle,
    legend=:bottomleft)
savefig(&quot;voltage_comparison_bus_$(case.bus[bus_to_plot, BUS_I]).png&quot;)

# 比较计算时间
using BenchmarkTools

println(&quot;完整潮流计算性能:&quot;)
@btime runtdpf($case, $load_file);

println(&quot;线性分布潮流计算性能:&quot;)
@btime runlindistflow($case, $load_file);</code></pre><h3 id="配电网应用"><a class="docs-heading-anchor" href="#配电网应用">配电网应用</a><a id="配电网应用-1"></a><a class="docs-heading-anchor-permalink" href="#配电网应用" title="Permalink"></a></h3><p>在配电网中应用线性分布潮流：</p><pre><code class="language-julia hljs"># 加载配电网测试系统
dist_case = load_case(&quot;case_distribution.m&quot;)

# 执行线性分布潮流计算
dist_lindist_results = runlindistflow(dist_case, load_file)

# 分析配电网中的电压分布
# 提取末端节点的电压
# 假设末端节点是编号最大的几个节点
num_end_nodes = 5
num_buses = size(dist_case.bus, 1)
end_nodes = (num_buses-num_end_nodes+1):num_buses

# 提取末端节点的电压时间序列
end_voltage = zeros(length(dist_lindist_results.time_points), length(end_nodes))

for t in 1:length(dist_lindist_results.time_points)
    if dist_lindist_results.success[t]
        for (i, node) in enumerate(end_nodes)
            end_voltage[t, i] = dist_lindist_results.bus_results[t].bus[node, VM]
        end
    end
end

# 绘制末端节点电压曲线
plot(dist_lindist_results.time_points, end_voltage,
    title=&quot;配电网末端节点电压&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;电压幅值(pu)&quot;,
    label=[&quot;节点 $(dist_case.bus[node, BUS_I])&quot; for node in end_nodes],
    legend=:bottomleft)
savefig(&quot;distribution_end_voltage.png&quot;)

# 检查电压越限情况
voltage_violations = (end_voltage .&lt; 0.95) .| (end_voltage .&gt; 1.05)
has_violations = any(voltage_violations)

if has_violations
    println(&quot;检测到电压越限情况:&quot;)
    for (i, node) in enumerate(end_nodes)
        node_violations = sum(voltage_violations[:, i])
        if node_violations &gt; 0
            println(&quot;  节点 $(dist_case.bus[node, BUS_I]) 有 $node_violations 个时间点电压越限&quot;)
        end
    end
end</code></pre><h2 id="违例分析与可视化"><a class="docs-heading-anchor" href="#违例分析与可视化">违例分析与可视化</a><a id="违例分析与可视化-1"></a><a class="docs-heading-anchor-permalink" href="#违例分析与可视化" title="Permalink"></a></h2><h3 id="电压违例分析"><a class="docs-heading-anchor" href="#电压违例分析">电压违例分析</a><a id="电压违例分析-1"></a><a class="docs-heading-anchor-permalink" href="#电压违例分析" title="Permalink"></a></h3><p>分析时间序列中的电压违例：</p><pre><code class="language-julia hljs"># 设置电压限制
v_min = 0.95
v_max = 1.05

# 分析电压违例
voltage_violations = analyze_voltage_violations(results, case, v_min, v_max)

# 显示违例摘要
println(&quot;电压违例摘要:&quot;)
println(&quot;  低电压违例数量: $(voltage_violations.low_count)&quot;)
println(&quot;  高电压违例数量: $(voltage_violations.high_count)&quot;)

# 如果有违例，显示详细信息
if voltage_violations.low_count &gt; 0 || voltage_violations.high_count &gt; 0
    println(&quot;违例详情:&quot;)
    
    # 低电压违例
    if voltage_violations.low_count &gt; 0
        println(&quot;  低电压违例:&quot;)
        for violation in voltage_violations.low_violations
            println(&quot;    时间点 $(violation.time), 母线 $(violation.bus_id): $(violation.value) pu&quot;)
        end
    end
    
    # 高电压违例
    if voltage_violations.high_count &gt; 0
        println(&quot;  高电压违例:&quot;)
        for violation in voltage_violations.high_violations
            println(&quot;    时间点 $(violation.time), 母线 $(violation.bus_id): $(violation.value) pu&quot;)
        end
    end
    
    # 绘制违例图表
    plot_voltage_violations(results, case, v_min, v_max)
end</code></pre><h3 id="支路功率流违例分析"><a class="docs-heading-anchor" href="#支路功率流违例分析">支路功率流违例分析</a><a id="支路功率流违例分析-1"></a><a class="docs-heading-anchor-permalink" href="#支路功率流违例分析" title="Permalink"></a></h3><p>分析时间序列中的支路功率流违例：</p><pre><code class="language-julia hljs"># 设置违例阈值(%)
flow_threshold = 90

# 分析支路功率流违例
flow_violations = analyze_flow_violations(results, case, flow_threshold)

# 显示违例摘要
println(&quot;支路功率流违例摘要:&quot;)
println(&quot;  违例数量: $(flow_violations.count)&quot;)

# 如果有违例，显示详细信息
if flow_violations.count &gt; 0
    println(&quot;违例详情:&quot;)
    for violation in flow_violations.violations
        from_bus = case.branch[violation.branch_idx, F_BUS]
        to_bus = case.branch[violation.branch_idx, T_BUS]
        println(&quot;  时间点 $(violation.time), 支路 $from_bus-$to_bus: $(violation.value)% of rating&quot;)
    end
    
    # 绘制违例图表
    plot_flow_violations(results, case, flow_threshold)
end</code></pre><h3 id="时间序列动画"><a class="docs-heading-anchor" href="#时间序列动画">时间序列动画</a><a id="时间序列动画-1"></a><a class="docs-heading-anchor-permalink" href="#时间序列动画" title="Permalink"></a></h3><p>创建时间序列结果的动画：</p><pre><code class="language-julia hljs">using Plots

# 创建电压分布动画
anim = @animate for t in 1:length(results.time_points)
    if results.success[t]
        result = results.bus_results[t]
        bar(result.bus[:, BUS_I], result.bus[:, VM],
            title=&quot;电压分布 - 时间点 $(results.time_points[t])&quot;,
            xlabel=&quot;母线编号&quot;,
            ylabel=&quot;电压幅值(pu)&quot;,
            ylims=(0.9, 1.1),
            legend=false)
    end
end

gif(anim, &quot;voltage_animation.gif&quot;, fps=2)

# 创建系统负荷和损耗动画
anim2 = @animate for t in 1:length(results.time_points)
    if results.success[t]
        result = results.bus_results[t]
        total_load = sum(result.bus[:, PD])
        total_loss = sum(result.branch[:, PL])
        
        bar([1, 2], [total_load, total_loss],
            title=&quot;系统负荷和损耗 - 时间点 $(results.time_points[t])&quot;,
            xlabel=&quot;&quot;,
            ylabel=&quot;功率(MW)&quot;,
            xticks=(1:2, [&quot;总负荷&quot;, &quot;总损耗&quot;]),
            legend=false)
    end
end

gif(anim2, &quot;load_loss_animation.gif&quot;, fps=2)</code></pre><h2 id="高级应用"><a class="docs-heading-anchor" href="#高级应用">高级应用</a><a id="高级应用-1"></a><a class="docs-heading-anchor-permalink" href="#高级应用" title="Permalink"></a></h2><h3 id="储能系统集成"><a class="docs-heading-anchor" href="#储能系统集成">储能系统集成</a><a id="储能系统集成-1"></a><a class="docs-heading-anchor-permalink" href="#储能系统集成" title="Permalink"></a></h3><p>模拟包含储能系统的时间序列潮流：</p><pre><code class="language-julia hljs"># 加载包含储能系统的案例
storage_case = load_case(&quot;case_with_storage.m&quot;)

# 设置储能调度选项
storage_opt = Dict(
    &quot;storage_control&quot; =&gt; &quot;optimal&quot;,
    &quot;verbose&quot; =&gt; 1
)

# 执行包含储能的时间序列潮流计算
storage_results = runtdpf(storage_case, load_file, irradiance_file, price_file, storage_opt)

# 分析储能系统的充放电行为
# 假设储能系统连接在特定母线上
storage_bus_id = 10
storage_p = zeros(length(storage_results.time_points))
storage_soc = zeros(length(storage_results.time_points))

for t in 1:length(storage_results.time_points)
    if storage_results.success[t]
        # 提取储能功率(正值表示放电，负值表示充电)
        storage_p[t] = storage_results.storage_results[t][storage_bus_id, STORAGE_P]
        # 提取储能SOC
        storage_soc[t] = storage_results.storage_results[t][storage_bus_id, STORAGE_SOC]
    end
end

# 绘制储能充放电曲线
p1 = plot(storage_results.time_points, storage_p,
    title=&quot;储能充放电功率&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;功率(MW)&quot;,
    marker=:circle,
    label=&quot;储能功率(正值为放电)&quot;)

# 绘制储能SOC曲线
p2 = plot(storage_results.time_points, storage_soc * 100,
    title=&quot;储能SOC&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;SOC(%)&quot;,
    marker=:circle,
    label=&quot;储能SOC&quot;)

# 组合图表
plot(p1, p2, layout=(2,1), size=(800, 600))
savefig(&quot;storage_behavior.png&quot;)

# 分析储能对系统的影响
# 比较有无储能的系统损耗
storage_loss = zeros(length(storage_results.time_points))
for t in 1:length(storage_results.time_points)
    if storage_results.success[t]
        storage_loss[t] = sum(storage_results.bus_results[t].branch[:, PL])
    end
end

# 绘制损耗比较曲线
plot(results.time_points, [total_loss storage_loss],
    title=&quot;系统损耗比较&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;系统损耗(MW)&quot;,
    label=[&quot;无储能&quot; &quot;有储能&quot;],
    marker=:circle,
    legend=:topleft)
savefig(&quot;loss_comparison_with_storage.png&quot;)</code></pre><h3 id="需求响应模拟"><a class="docs-heading-anchor" href="#需求响应模拟">需求响应模拟</a><a id="需求响应模拟-1"></a><a class="docs-heading-anchor-permalink" href="#需求响应模拟" title="Permalink"></a></h3><p>模拟需求响应对系统的影响：</p><pre><code class="language-julia hljs"># 设置需求响应选项
dr_opt = Dict(
    &quot;demand_response&quot; =&gt; true,
    &quot;dr_price_threshold&quot; =&gt; 50,  # 当电价超过此值时触发需求响应
    &quot;dr_reduction&quot; =&gt; 0.1,       # 需求响应减少10%的负荷
    &quot;verbose&quot; =&gt; 1
)

# 执行包含需求响应的时间序列潮流计算
dr_results = runtdpf(case, load_file, irradiance_file, price_file, dr_opt)

# 分析需求响应的效果
dr_load = zeros(length(dr_results.time_points))
for t in 1:length(dr_results.time_points)
    if dr_results.success[t]
        dr_load[t] = sum(dr_results.bus_results[t].bus[:, PD])
    end
end

# 绘制需求响应效果
plot(results.time_points, [total_load dr_load],
    title=&quot;需求响应效果&quot;,
    xlabel=&quot;时间(小时)&quot;,
    ylabel=&quot;总负荷(MW)&quot;,
    label=[&quot;基准负荷&quot; &quot;需求响应后负荷&quot;],
    marker=:circle,
    legend=:topleft)
savefig(&quot;demand_response_effect.png&quot;)

# 计算需求响应的经济效益
if !isempty(dr_results.prices)
    base_cost = sum(total_load .* dr_results.prices)
    dr_cost = sum(dr_load .* dr_results.prices)
    savings = base_cost - dr_cost
    
    println(&quot;需求响应经济效益分析:&quot;)
    println(&quot;  基准情况总成本: $base_cost $&quot;)
    println(&quot;  需求响应后总成本: $dr_cost $&quot;)
    println(&quot;  节约成本: $savings $ ($(savings/base_cost*100)%)&quot;)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="power_flow.html">« 潮流计算示例</a><a class="docs-footer-nextpage" href="visualization.html">可视化示例 »</a><div class="flexbox-break"></div><p class="footer-message">电力系统建模与分析工具集</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Thursday 3 July 2025 23:11">Thursday 3 July 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
