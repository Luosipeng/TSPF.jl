<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>潮流计算示例 · 电力系统建模与分析工具集</title><meta name="title" content="潮流计算示例 · 电力系统建模与分析工具集"/><meta property="og:title" content="潮流计算示例 · 电力系统建模与分析工具集"/><meta property="twitter:title" content="潮流计算示例 · 电力系统建模与分析工具集"/><meta name="description" content="Documentation for 电力系统建模与分析工具集."/><meta property="og:description" content="Documentation for 电力系统建模与分析工具集."/><meta property="twitter:description" content="Documentation for 电力系统建模与分析工具集."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">首页</a></li><li><a class="tocitem" href="../getting_started.html">入门指南</a></li><li><span class="tocitem">API参考</span><ul><li><a class="tocitem" href="../api/overview.html">概述</a></li><li><a class="tocitem" href="../api/component_model.html">ComponentModel模块</a></li><li><a class="tocitem" href="../api/power_flow.html">PowerFlow模块</a></li><li><a class="tocitem" href="../api/utils.html">Utils模块</a></li><li><a class="tocitem" href="../api/time_series_power_flow.html">TimeSeriesPowerFlow模块</a></li></ul></li><li><span class="tocitem">函数说明</span><ul><li><a class="tocitem" href="../functions/component_functions.html">组件函数</a></li><li><a class="tocitem" href="../functions/power_flow_functions.html">潮流计算函数</a></li><li><a class="tocitem" href="../functions/utils_functions.html">工具函数</a></li><li><a class="tocitem" href="../functions/time_series_functions.html">时序潮流函数</a></li></ul></li><li><a class="tocitem" href="../main.html">主程序说明</a></li><li><span class="tocitem">示例</span><ul><li><a class="tocitem" href="basic.html">基础示例</a></li><li class="is-active"><a class="tocitem" href="power_flow.html">潮流计算示例</a><ul class="internal"><li><a class="tocitem" href="#基础潮流计算"><span>基础潮流计算</span></a></li><li><a class="tocitem" href="#直流潮流计算"><span>直流潮流计算</span></a></li><li><a class="tocitem" href="#不平衡潮流计算"><span>不平衡潮流计算</span></a></li><li><a class="tocitem" href="#高级选项与自定义"><span>高级选项与自定义</span></a></li><li><a class="tocitem" href="#GPU加速计算"><span>GPU加速计算</span></a></li><li><a class="tocitem" href="#混合交直流系统"><span>混合交直流系统</span></a></li><li><a class="tocitem" href="#结果分析与处理"><span>结果分析与处理</span></a></li><li><a class="tocitem" href="#高级应用"><span>高级应用</span></a></li><li><a class="tocitem" href="#结论"><span>结论</span></a></li></ul></li><li><a class="tocitem" href="time_series.html">时序潮流示例</a></li><li><a class="tocitem" href="visualization.html">可视化示例</a></li></ul></li><li><a class="tocitem" href="../development.html">开发指南</a></li><li><a class="tocitem" href="../faq.html">常见问题</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">示例</a></li><li class="is-active"><a href="power_flow.html">潮流计算示例</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="power_flow.html">潮流计算示例</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Matrixeigs/DistributionPowerFlow" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/Matrixeigs/DistributionPowerFlow/blob/master/docs/src/examples/power_flow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PowerFlow-模块示例"><a class="docs-heading-anchor" href="#PowerFlow-模块示例">PowerFlow 模块示例</a><a id="PowerFlow-模块示例-1"></a><a class="docs-heading-anchor-permalink" href="#PowerFlow-模块示例" title="Permalink"></a></h1><p>本文档提供了 PowerFlow 模块的详细使用示例，展示了各种潮流计算算法的应用、高级选项配置以及结果分析方法。这些示例旨在帮助用户深入理解 PowerFlow 模块的核心功能。</p><h2 id="基础潮流计算"><a class="docs-heading-anchor" href="#基础潮流计算">基础潮流计算</a><a id="基础潮流计算-1"></a><a class="docs-heading-anchor-permalink" href="#基础潮流计算" title="Permalink"></a></h2><h3 id="牛顿-拉夫森法潮流计算"><a class="docs-heading-anchor" href="#牛顿-拉夫森法潮流计算">牛顿-拉夫森法潮流计算</a><a id="牛顿-拉夫森法潮流计算-1"></a><a class="docs-heading-anchor-permalink" href="#牛顿-拉夫森法潮流计算" title="Permalink"></a></h3><p>牛顿-拉夫森法是最常用的潮流计算方法，适用于大多数电力系统：</p><pre><code class="language-julia hljs">using PowerFlow

# 加载标准测试系统
case = load_case(&quot;case14.m&quot;)

# 使用牛顿-拉夫森法计算潮流
opt = Dict(&quot;pf_alg&quot; =&gt; &quot;NR&quot;, &quot;verbose&quot; =&gt; 1)
results = runpf(case, opt)

# 显示收敛过程
println(&quot;迭代次数: $(results.iterations)&quot;)
println(&quot;最终误差: $(results.max_mismatch)&quot;)

# 查看计算结果
println(&quot;系统总发电: $(sum(results.gen[:, PG])) MW&quot;)
println(&quot;系统总负荷: $(sum(results.bus[:, PD])) MW&quot;)
println(&quot;系统总损耗: $(sum(results.branch[:, PL])) MW&quot;)</code></pre><h3 id="快速解耦潮流计算"><a class="docs-heading-anchor" href="#快速解耦潮流计算">快速解耦潮流计算</a><a id="快速解耦潮流计算-1"></a><a class="docs-heading-anchor-permalink" href="#快速解耦潮流计算" title="Permalink"></a></h3><p>快速解耦法在某些情况下可以提供更快的计算速度：</p><pre><code class="language-julia hljs"># 使用快速解耦法计算潮流
opt = Dict(&quot;pf_alg&quot; =&gt; &quot;FDXB&quot;, &quot;verbose&quot; =&gt; 1)
fdxb_results = runpf(case, opt)

# 比较与牛顿-拉夫森法的结果
println(&quot;牛顿-拉夫森法迭代次数: $(results.iterations)&quot;)
println(&quot;快速解耦法迭代次数: $(fdxb_results.iterations)&quot;)

# 比较计算精度
nr_losses = sum(results.branch[:, PL])
fdxb_losses = sum(fdxb_results.branch[:, PL])
println(&quot;牛顿-拉夫森法计算的系统损耗: $nr_losses MW&quot;)
println(&quot;快速解耦法计算的系统损耗: $fdxb_losses MW&quot;)
println(&quot;相对误差: $(abs(nr_losses - fdxb_losses) / nr_losses * 100)%&quot;)</code></pre><h3 id="高斯-赛德尔法潮流计算"><a class="docs-heading-anchor" href="#高斯-赛德尔法潮流计算">高斯-赛德尔法潮流计算</a><a id="高斯-赛德尔法潮流计算-1"></a><a class="docs-heading-anchor-permalink" href="#高斯-赛德尔法潮流计算" title="Permalink"></a></h3><p>高斯-赛德尔法适用于某些特定类型的系统：</p><pre><code class="language-julia hljs"># 使用高斯-赛德尔法计算潮流
opt = Dict(&quot;pf_alg&quot; =&gt; &quot;GS&quot;, &quot;verbose&quot; =&gt; 1, &quot;max_it&quot; =&gt; 100)
gs_results = runpf(case, opt)

# 比较计算结果
println(&quot;高斯-赛德尔法迭代次数: $(gs_results.iterations)&quot;)
println(&quot;高斯-赛德尔法计算的系统损耗: $(sum(gs_results.branch[:, PL])) MW&quot;)</code></pre><h2 id="直流潮流计算"><a class="docs-heading-anchor" href="#直流潮流计算">直流潮流计算</a><a id="直流潮流计算-1"></a><a class="docs-heading-anchor-permalink" href="#直流潮流计算" title="Permalink"></a></h2><h3 id="基本直流潮流"><a class="docs-heading-anchor" href="#基本直流潮流">基本直流潮流</a><a id="基本直流潮流-1"></a><a class="docs-heading-anchor-permalink" href="#基本直流潮流" title="Permalink"></a></h3><p>直流潮流提供了快速的近似解：</p><pre><code class="language-julia hljs"># 执行直流潮流计算
dc_results = rundcpf(case)

# 查看计算结果
println(&quot;直流潮流计算的系统总发电: $(sum(dc_results.gen[:, PG])) MW&quot;)
println(&quot;直流潮流计算的系统总负荷: $(sum(dc_results.bus[:, PD])) MW&quot;)

# 比较交流和直流潮流的计算速度
using BenchmarkTools

println(&quot;交流潮流计算性能:&quot;)
@btime runpf($case);

println(&quot;直流潮流计算性能:&quot;)
@btime rundcpf($case);</code></pre><h3 id="直流潮流的线性敏感度分析"><a class="docs-heading-anchor" href="#直流潮流的线性敏感度分析">直流潮流的线性敏感度分析</a><a id="直流潮流的线性敏感度分析-1"></a><a class="docs-heading-anchor-permalink" href="#直流潮流的线性敏感度分析" title="Permalink"></a></h3><p>直流潮流可用于快速进行线性敏感度分析：</p><pre><code class="language-julia hljs"># 计算功率传输分布因子(PTDF)
ptdf_matrix = calc_ptdf(case)

# 查看特定线路对特定注入的敏感度
line_idx = 5
bus_idx = 3
println(&quot;线路 $(case.branch[line_idx, F_BUS])-$(case.branch[line_idx, T_BUS]) 对母线 $bus_idx 注入的敏感度: $(ptdf_matrix[line_idx, bus_idx])&quot;)

# 计算线路中断因子(LODF)
lodf_matrix = calc_lodf(case)

# 查看特定线路中断对其他线路的影响
outage_line = 1
affected_line = 5
println(&quot;线路 $(case.branch[outage_line, F_BUS])-$(case.branch[outage_line, T_BUS]) 中断对线路 $(case.branch[affected_line, F_BUS])-$(case.branch[affected_line, T_BUS]) 的影响系数: $(lodf_matrix[affected_line, outage_line])&quot;)</code></pre><h2 id="不平衡潮流计算"><a class="docs-heading-anchor" href="#不平衡潮流计算">不平衡潮流计算</a><a id="不平衡潮流计算-1"></a><a class="docs-heading-anchor-permalink" href="#不平衡潮流计算" title="Permalink"></a></h2><h3 id="三相不平衡潮流"><a class="docs-heading-anchor" href="#三相不平衡潮流">三相不平衡潮流</a><a id="三相不平衡潮流-1"></a><a class="docs-heading-anchor-permalink" href="#三相不平衡潮流" title="Permalink"></a></h3><p>处理三相不平衡系统：</p><pre><code class="language-julia hljs"># 加载三相不平衡系统案例
unbalanced_case = load_case(&quot;case_unbalanced.m&quot;)

# 执行不平衡潮流计算
opt = Dict(&quot;verbose&quot; =&gt; 1)
upf_results = runupf(unbalanced_case, opt)

# 查看各相电压
for i in 1:size(upf_results.bus, 1)
    bus_id = upf_results.bus[i, BUS_I]
    println(&quot;母线 $bus_id:&quot;)
    println(&quot;  A相电压: $(upf_results.bus[i, VM_A]) ∠ $(upf_results.bus[i, VA_A])°&quot;)
    println(&quot;  B相电压: $(upf_results.bus[i, VM_B]) ∠ $(upf_results.bus[i, VA_B])°&quot;)
    println(&quot;  C相电压: $(upf_results.bus[i, VM_C]) ∠ $(upf_results.bus[i, VA_C])°&quot;)
end

# 计算电压不平衡度
for i in 1:size(upf_results.bus, 1)
    vm_a = upf_results.bus[i, VM_A]
    vm_b = upf_results.bus[i, VM_B]
    vm_c = upf_results.bus[i, VM_C]
    
    vm_avg = (vm_a + vm_b + vm_c) / 3
    vm_dev = max(abs(vm_a - vm_avg), abs(vm_b - vm_avg), abs(vm_c - vm_avg))
    vuf = vm_dev / vm_avg * 100  # 电压不平衡度(%)
    
    println(&quot;母线 $(upf_results.bus[i, BUS_I]) 电压不平衡度: $vuf%&quot;)
end</code></pre><h2 id="高级选项与自定义"><a class="docs-heading-anchor" href="#高级选项与自定义">高级选项与自定义</a><a id="高级选项与自定义-1"></a><a class="docs-heading-anchor-permalink" href="#高级选项与自定义" title="Permalink"></a></h2><h3 id="自定义收敛标准"><a class="docs-heading-anchor" href="#自定义收敛标准">自定义收敛标准</a><a id="自定义收敛标准-1"></a><a class="docs-heading-anchor-permalink" href="#自定义收敛标准" title="Permalink"></a></h3><p>设置自定义的收敛标准：</p><pre><code class="language-julia hljs"># 设置严格的收敛标准
strict_opt = Dict(
    &quot;pf_tol&quot; =&gt; 1e-8,        # 更严格的收敛容差
    &quot;max_it&quot; =&gt; 50,          # 增加最大迭代次数
    &quot;verbose&quot; =&gt; 2           # 更详细的输出
)

# 执行潮流计算
strict_results = runpf(case, strict_opt)

println(&quot;使用严格收敛标准:&quot;)
println(&quot;  迭代次数: $(strict_results.iterations)&quot;)
println(&quot;  最终误差: $(strict_results.max_mismatch)&quot;)</code></pre><h3 id="自定义起始点"><a class="docs-heading-anchor" href="#自定义起始点">自定义起始点</a><a id="自定义起始点-1"></a><a class="docs-heading-anchor-permalink" href="#自定义起始点" title="Permalink"></a></h3><p>设置自定义的计算起始点：</p><pre><code class="language-julia hljs"># 保存原始案例数据
original_case = deepcopy(case)

# 修改起始电压值
for i in 1:size(case.bus, 1)
    # 设置平坦起始点
    case.bus[i, VM] = 1.0
    case.bus[i, VA] = 0.0
end

# 使用平坦起始点计算潮流
flat_results = runpf(case)

# 使用&quot;热启动&quot;起始点
warm_start_case = deepcopy(original_case)
# 将上一次的结果作为起始点
for i in 1:size(warm_start_case.bus, 1)
    bus_idx = findfirst(x -&gt; x == warm_start_case.bus[i, BUS_I], flat_results.bus[:, BUS_I])
    if bus_idx !== nothing
        warm_start_case.bus[i, VM] = flat_results.bus[bus_idx, VM]
        warm_start_case.bus[i, VA] = flat_results.bus[bus_idx, VA]
    end
end

# 使用热启动点计算潮流
warm_results = runpf(warm_start_case)

# 比较迭代次数
println(&quot;平坦起始点迭代次数: $(flat_results.iterations)&quot;)
println(&quot;热启动起始点迭代次数: $(warm_results.iterations)&quot;)</code></pre><h3 id="处理收敛问题"><a class="docs-heading-anchor" href="#处理收敛问题">处理收敛问题</a><a id="处理收敛问题-1"></a><a class="docs-heading-anchor-permalink" href="#处理收敛问题" title="Permalink"></a></h3><p>处理难以收敛的情况：</p><pre><code class="language-julia hljs"># 创建一个难以收敛的案例
difficult_case = deepcopy(case)
# 增加负荷，减少电压支撑
difficult_case.bus[:, PD] *= 1.5
# 降低发电机电压设定点
difficult_case.gen[:, VG] *= 0.95

# 尝试标准计算
try
    standard_results = runpf(difficult_case)
    println(&quot;标准方法成功收敛&quot;)
catch e
    println(&quot;标准方法未能收敛: $e&quot;)
    
    # 使用改进的选项
    robust_opt = Dict(
        &quot;pf_alg&quot; =&gt; &quot;NR&quot;,
        &quot;max_it&quot; =&gt; 100,       # 增加迭代次数
        &quot;pf_tol&quot; =&gt; 1e-4,      # 放宽收敛标准
        &quot;enforce_q_lims&quot; =&gt; 0, # 暂时不考虑无功限制
        &quot;verbose&quot; =&gt; 2
    )
    
    try
        robust_results = runpf(difficult_case, robust_opt)
        println(&quot;改进方法成功收敛，迭代次数: $(robust_results.iterations)&quot;)
    catch e2
        println(&quot;改进方法仍未收敛: $e2&quot;)
        
        # 使用连续潮流法
        continuation_opt = Dict(
            &quot;pf_alg&quot; =&gt; &quot;CONT&quot;,  # 连续潮流法
            &quot;verbose&quot; =&gt; 2
        )
        
        try
            cont_results = runpf(difficult_case, continuation_opt)
            println(&quot;连续潮流法成功收敛&quot;)
        catch e3
            println(&quot;连续潮流法未能收敛: $e3&quot;)
        end
    end
end</code></pre><h2 id="GPU加速计算"><a class="docs-heading-anchor" href="#GPU加速计算">GPU加速计算</a><a id="GPU加速计算-1"></a><a class="docs-heading-anchor-permalink" href="#GPU加速计算" title="Permalink"></a></h2><h3 id="使用GPU加速大规模系统计算"><a class="docs-heading-anchor" href="#使用GPU加速大规模系统计算">使用GPU加速大规模系统计算</a><a id="使用GPU加速大规模系统计算-1"></a><a class="docs-heading-anchor-permalink" href="#使用GPU加速大规模系统计算" title="Permalink"></a></h3><p>对于大规模系统，可以使用GPU加速计算：</p><pre><code class="language-julia hljs"># 检查是否有可用的GPU
using CUDA
if CUDA.functional()
    # 加载大规模系统
    large_case = load_case(&quot;case1888rte.m&quot;)
    
    # 使用CPU计算
    println(&quot;使用CPU计算...&quot;)
    @time cpu_results = runpf(large_case)
    
    # 使用GPU加速计算
    println(&quot;使用GPU加速计算...&quot;)
    gpu_opt = Dict(&quot;use_gpu&quot; =&gt; true)
    @time gpu_results = runpf(large_case, gpu_opt)
    
    # 比较结果
    cpu_losses = sum(cpu_results.branch[:, PL])
    gpu_losses = sum(gpu_results.branch[:, PL])
    println(&quot;CPU计算的系统损耗: $cpu_losses MW&quot;)
    println(&quot;GPU计算的系统损耗: $gpu_losses MW&quot;)
    println(&quot;相对误差: $(abs(cpu_losses - gpu_losses) / cpu_losses * 100)%&quot;)
else
    println(&quot;没有可用的GPU或CUDA环境&quot;)
end</code></pre><h2 id="混合交直流系统"><a class="docs-heading-anchor" href="#混合交直流系统">混合交直流系统</a><a id="混合交直流系统-1"></a><a class="docs-heading-anchor-permalink" href="#混合交直流系统" title="Permalink"></a></h2><h3 id="混合交直流潮流计算"><a class="docs-heading-anchor" href="#混合交直流潮流计算">混合交直流潮流计算</a><a id="混合交直流潮流计算-1"></a><a class="docs-heading-anchor-permalink" href="#混合交直流潮流计算" title="Permalink"></a></h3><p>计算包含交流和直流部分的混合系统：</p><pre><code class="language-julia hljs"># 加载混合交直流系统案例
hybrid_case = load_case(&quot;case_hybrid.m&quot;)

# 执行混合交直流潮流计算
hybrid_results = runpf(hybrid_case)

# 查看交流部分结果
println(&quot;交流系统结果:&quot;)
println(&quot;  交流母线数量: $(sum(hybrid_results.bus[:, BUS_TYPE] .!= BUS_TYPE_DC))&quot;)
println(&quot;  交流系统总发电: $(sum(hybrid_results.gen[hybrid_results.gen[:, GEN_STATUS] .== 1, PG])) MW&quot;)
println(&quot;  交流系统总负荷: $(sum(hybrid_results.bus[hybrid_results.bus[:, BUS_TYPE] .!= BUS_TYPE_DC, PD])) MW&quot;)
println(&quot;  交流系统总损耗: $(sum(hybrid_results.branch[hybrid_results.branch[:, BR_TYPE] .== BR_TYPE_AC, PL])) MW&quot;)

# 查看直流部分结果
println(&quot;直流系统结果:&quot;)
println(&quot;  直流母线数量: $(sum(hybrid_results.bus[:, BUS_TYPE] .== BUS_TYPE_DC))&quot;)
println(&quot;  直流系统总负荷: $(sum(hybrid_results.bus[hybrid_results.bus[:, BUS_TYPE] .== BUS_TYPE_DC, PD])) MW&quot;)
println(&quot;  直流系统总损耗: $(sum(hybrid_results.branch[hybrid_results.branch[:, BR_TYPE] .== BR_TYPE_DC, PL])) MW&quot;)

# 查看换流器结果
println(&quot;换流器结果:&quot;)
for i in 1:size(hybrid_results.converter, 1)
    conv_id = hybrid_results.converter[i, CONV_ID]
    ac_bus = hybrid_results.converter[i, CONV_AC_BUS]
    dc_bus = hybrid_results.converter[i, CONV_DC_BUS]
    p_ac = hybrid_results.converter[i, CONV_P_AC]
    p_dc = hybrid_results.converter[i, CONV_P_DC]
    loss = hybrid_results.converter[i, CONV_LOSS]
    
    println(&quot;  换流器 $conv_id (AC母线 $ac_bus - DC母线 $dc_bus):&quot;)
    println(&quot;    交流侧功率: $p_ac MW&quot;)
    println(&quot;    直流侧功率: $p_dc MW&quot;)
    println(&quot;    换流损耗: $loss MW&quot;)
    println(&quot;    效率: $((abs(p_dc) / abs(p_ac)) * 100)%&quot;)
end</code></pre><h2 id="结果分析与处理"><a class="docs-heading-anchor" href="#结果分析与处理">结果分析与处理</a><a id="结果分析与处理-1"></a><a class="docs-heading-anchor-permalink" href="#结果分析与处理" title="Permalink"></a></h2><h3 id="详细的结果分析"><a class="docs-heading-anchor" href="#详细的结果分析">详细的结果分析</a><a id="详细的结果分析-1"></a><a class="docs-heading-anchor-permalink" href="#详细的结果分析" title="Permalink"></a></h3><p>深入分析潮流计算结果：</p><pre><code class="language-julia hljs"># 执行潮流计算
results = runpf(case)

# 分析母线电压分布
vm = results.bus[:, VM]
va = results.bus[:, VA]

println(&quot;电压统计:&quot;)
println(&quot;  最高电压: $(maximum(vm)) pu，位于母线 $(results.bus[argmax(vm), BUS_I])&quot;)
println(&quot;  最低电压: $(minimum(vm)) pu，位于母线 $(results.bus[argmin(vm), BUS_I])&quot;)
println(&quot;  平均电压: $(mean(vm)) pu&quot;)
println(&quot;  标准差: $(std(vm)) pu&quot;)

# 分析支路功率流
branch_flow = results.branch[:, PF]
branch_from = results.branch[:, F_BUS]
branch_to = results.branch[:, T_BUS]
branch_rate = results.branch[:, RATE_A]

# 计算支路负载率
loading_rate = abs.(branch_flow) ./ branch_rate * 100
branch_rate_valid = branch_rate .&gt; 0  # 只考虑有额定值的支路

if any(branch_rate_valid)
    max_loading_idx = argmax(loading_rate .* branch_rate_valid)
    println(&quot;支路负载率统计(对有额定值的支路):&quot;)
    println(&quot;  最高负载率: $(loading_rate[max_loading_idx])%，位于支路 $(branch_from[max_loading_idx])-$(branch_to[max_loading_idx])&quot;)
    println(&quot;  平均负载率: $(mean(loading_rate[branch_rate_valid]))%&quot;)
end

# 分析发电机出力
gen_pg = results.gen[:, PG]
gen_qg = results.gen[:, QG]
gen_bus = results.gen[:, GEN_BUS]
gen_pmax = results.gen[:, PMAX]
gen_pmin = results.gen[:, PMIN]
gen_qmax = results.gen[:, QMAX]
gen_qmin = results.gen[:, QMIN]

# 检查发电机是否达到限制
p_at_max = abs.(gen_pg - gen_pmax) .&lt; 1e-3
p_at_min = abs.(gen_pg - gen_pmin) .&lt; 1e-3
q_at_max = abs.(gen_qg - gen_qmax) .&lt; 1e-3
q_at_min = abs.(gen_qg - gen_qmin) .&lt; 1e-3

println(&quot;发电机限制状态:&quot;)
println(&quot;  有功达到上限的发电机数量: $(sum(p_at_max))&quot;)
println(&quot;  有功达到下限的发电机数量: $(sum(p_at_min))&quot;)
println(&quot;  无功达到上限的发电机数量: $(sum(q_at_max))&quot;)
println(&quot;  无功达到下限的发电机数量: $(sum(q_at_min))&quot;)

# 分析系统损耗
total_gen = sum(gen_pg)
total_load = sum(results.bus[:, PD])
total_loss = total_gen - total_load

println(&quot;系统损耗分析:&quot;)
println(&quot;  总发电: $total_gen MW&quot;)
println(&quot;  总负荷: $total_load MW&quot;)
println(&quot;  总损耗: $total_loss MW&quot;)
println(&quot;  损耗率: $(total_loss / total_gen * 100)%&quot;)</code></pre><h3 id="结果导出与可视化"><a class="docs-heading-anchor" href="#结果导出与可视化">结果导出与可视化</a><a id="结果导出与可视化-1"></a><a class="docs-heading-anchor-permalink" href="#结果导出与可视化" title="Permalink"></a></h3><p>导出和可视化计算结果：</p><pre><code class="language-julia hljs">using DataFrames, CSV, Plots

# 将结果转换为DataFrame格式
# 母线结果
bus_df = DataFrame(
    Bus_ID = results.bus[:, BUS_I],
    Type = results.bus[:, BUS_TYPE],
    Voltage_Magnitude = results.bus[:, VM],
    Voltage_Angle = results.bus[:, VA],
    Load_MW = results.bus[:, PD],
    Load_MVAr = results.bus[:, QD]
)

# 支路结果
branch_df = DataFrame(
    From_Bus = results.branch[:, F_BUS],
    To_Bus = results.branch[:, T_BUS],
    Power_Flow_MW = results.branch[:, PF],
    Power_Flow_MVAr = results.branch[:, QF],
    Loss_MW = results.branch[:, PL],
    Loss_MVAr = results.branch[:, QL]
)

# 发电机结果
gen_df = DataFrame(
    Bus_ID = results.gen[:, GEN_BUS],
    Active_Power_MW = results.gen[:, PG],
    Reactive_Power_MVAr = results.gen[:, QG],
    Voltage_Setpoint = results.gen[:, VG]
)

# 导出到CSV文件
CSV.write(&quot;bus_results.csv&quot;, bus_df)
CSV.write(&quot;branch_results.csv&quot;, branch_df)
CSV.write(&quot;gen_results.csv&quot;, gen_df)

# 创建电压分布图
p1 = bar(bus_df.Bus_ID, bus_df.Voltage_Magnitude,
    title=&quot;母线电压分布&quot;,
    xlabel=&quot;母线编号&quot;,
    ylabel=&quot;电压幅值(pu)&quot;,
    legend=false)

# 创建功率流分布图
p2 = bar(1:size(branch_df, 1), abs.(branch_df.Power_Flow_MW),
    title=&quot;支路功率流分布&quot;,
    xlabel=&quot;支路编号&quot;,
    ylabel=&quot;功率流大小(MW)&quot;,
    legend=false)

# 创建损耗分布图
p3 = bar(1:size(branch_df, 1), branch_df.Loss_MW,
    title=&quot;支路损耗分布&quot;,
    xlabel=&quot;支路编号&quot;,
    ylabel=&quot;有功损耗(MW)&quot;,
    legend=false)

# 组合图表
plot(p1, p2, p3, layout=(3,1), size=(800, 1200))
savefig(&quot;power_flow_results.png&quot;)</code></pre><h2 id="高级应用"><a class="docs-heading-anchor" href="#高级应用">高级应用</a><a id="高级应用-1"></a><a class="docs-heading-anchor-permalink" href="#高级应用" title="Permalink"></a></h2><h3 id="或然性分析"><a class="docs-heading-anchor" href="#或然性分析">或然性分析</a><a id="或然性分析-1"></a><a class="docs-heading-anchor-permalink" href="#或然性分析" title="Permalink"></a></h3><p>进行简单的或然性分析：</p><pre><code class="language-julia hljs"># 定义要分析的线路中断情况
outage_branches = [1, 5, 10]

# 保存原始案例
base_case = deepcopy(case)
base_results = runpf(base_case)

println(&quot;基础情况:&quot;)
println(&quot;  总发电: $(sum(base_results.gen[:, PG])) MW&quot;)
println(&quot;  总损耗: $(sum(base_results.branch[:, PL])) MW&quot;)
println(&quot;  最低电压: $(minimum(base_results.bus[:, VM])) pu&quot;)

# 分析每个中断情况
for br_idx in outage_branches
    # 创建中断情况
    outage_case = deepcopy(base_case)
    from_bus = outage_case.branch[br_idx, F_BUS]
    to_bus = outage_case.branch[br_idx, T_BUS]
    outage_case.branch[br_idx, BR_STATUS] = 0  # 断开线路
    
    println(&quot;\n分析线路 $from_bus-$to_bus 中断情况:&quot;)
    
    # 执行潮流计算
    try
        outage_results = runpf(outage_case)
        
        # 分析结果
        total_gen = sum(outage_results.gen[:, PG])
        total_loss = sum(outage_results.branch[:, PL])
        min_voltage = minimum(outage_results.bus[:, VM])
        
        # 找出最大负载率
        loading_rate = abs.(outage_results.branch[:, PF]) ./ outage_results.branch[:, RATE_A] * 100
        branch_rate_valid = outage_results.branch[:, RATE_A] .&gt; 0
        if any(branch_rate_valid)
            max_loading = maximum(loading_rate .* branch_rate_valid)
            max_loading_idx = argmax(loading_rate .* branch_rate_valid)
            overloaded = loading_rate .&gt; 100 .&amp; branch_rate_valid
            
            println(&quot;  总发电: $total_gen MW&quot;)
            println(&quot;  总损耗: $total_loss MW&quot;)
            println(&quot;  最低电压: $min_voltage pu&quot;)
            println(&quot;  最大支路负载率: $max_loading%&quot;)
            println(&quot;  过载支路数量: $(sum(overloaded))&quot;)
            
            if sum(overloaded) &gt; 0
                for i in findall(overloaded)
                    from = outage_results.branch[i, F_BUS]
                    to = outage_results.branch[i, T_BUS]
                    load_rate = loading_rate[i]
                    println(&quot;    过载支路 $from-$to: $load_rate%&quot;)
                end
            end
        end
    catch e
        println(&quot;  潮流计算未收敛: $e&quot;)
    end
end</code></pre><h3 id="灵敏度分析"><a class="docs-heading-anchor" href="#灵敏度分析">灵敏度分析</a><a id="灵敏度分析-1"></a><a class="docs-heading-anchor-permalink" href="#灵敏度分析" title="Permalink"></a></h3><p>进行简单的灵敏度分析：</p><pre><code class="language-julia hljs"># 执行基础潮流计算
base_results = runpf(case)
base_losses = sum(base_results.branch[:, PL])

# 定义要分析的参数和变化范围
load_factors = 0.8:0.05:1.2

# 存储结果
loss_results = zeros(length(load_factors))
voltage_results = zeros(length(load_factors))

# 进行灵敏度分析
for (i, factor) in enumerate(load_factors)
    # 修改负荷
    test_case = deepcopy(case)
    test_case.bus[:, PD] = case.bus[:, PD] * factor
    test_case.bus[:, QD] = case.bus[:, QD] * factor
    
    # 执行潮流计算
    try
        test_results = runpf(test_case)
        
        # 记录结果
        loss_results[i] = sum(test_results.branch[:, PL])
        voltage_results[i] = minimum(test_results.bus[:, VM])
    catch e
        println(&quot;负荷因子 $factor 时潮流计算未收敛: $e&quot;)
        loss_results[i] = NaN
        voltage_results[i] = NaN
    end
end

# 计算灵敏度
valid_indices = .!isnan.(loss_results)
if sum(valid_indices) &gt;= 2
    # 计算损耗对负荷的灵敏度
    loss_sensitivity = (loss_results[valid_indices] .- base_losses) ./ (load_factors[valid_indices] .- 1.0) ./ base_losses
    
    println(&quot;损耗对负荷变化的灵敏度:&quot;)
    for (f, s) in zip(load_factors[valid_indices], loss_sensitivity)
        println(&quot;  负荷因子 $f: 灵敏度 $s&quot;)
    end
    
    # 绘制灵敏度曲线
    p1 = plot(load_factors, loss_results,
        title=&quot;系统损耗对负荷变化的灵敏度&quot;,
        xlabel=&quot;负荷因子&quot;,
        ylabel=&quot;系统损耗(MW)&quot;,
        marker=:circle,
        label=&quot;系统损耗&quot;)
    
    p2 = plot(load_factors, voltage_results,
        title=&quot;最低电压对负荷变化的灵敏度&quot;,
        xlabel=&quot;负荷因子&quot;,
        ylabel=&quot;最低电压(pu)&quot;,
        marker=:circle,
        label=&quot;最低电压&quot;)
    
    plot(p1, p2, layout=(2,1), size=(800, 800))
    savefig(&quot;sensitivity_analysis.png&quot;)
end</code></pre><h2 id="结论"><a class="docs-heading-anchor" href="#结论">结论</a><a id="结论-1"></a><a class="docs-heading-anchor-permalink" href="#结论" title="Permalink"></a></h2><p>本文档展示了 PowerFlow 模块的各种功能和应用场景，从基础的潮流计算到高级的系统分析。通过这些示例，用户可以了解如何:</p><ol><li>使用不同的潮流计算算法</li><li>配置高级计算选项</li><li>处理混合交直流系统</li><li>分析和可视化计算结果</li><li>进行或然性和灵敏度分析</li></ol><p>PowerFlow 模块提供了强大而灵活的功能，可以满足从教学到研究再到工程实践的各种需求。通过合理配置和使用这些功能，用户可以高效地分析和解决电力系统中的各种问题。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="basic.html">« 基础示例</a><a class="docs-footer-nextpage" href="time_series.html">时序潮流示例 »</a><div class="flexbox-break"></div><p class="footer-message">电力系统建模与分析工具集</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.13.0 on <span class="colophon-date" title="Thursday 3 July 2025 23:11">Thursday 3 July 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
