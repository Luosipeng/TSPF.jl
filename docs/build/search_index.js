var documenterSearchIndex = {"docs":
[{"location":"api/powerflow.html#API-Reference","page":"PowerFlow API","title":"API Reference","text":"","category":"section"},{"location":"api/powerflow.html#Power-Flow-Algorithm","page":"PowerFlow API","title":"Power Flow Algorithm","text":"","category":"section"},{"location":"api/powerflow.html#PowerFlow.adaptive_damped_newton","page":"PowerFlow API","title":"PowerFlow.adaptive_damped_newton","text":"adaptive_damped_newton(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=\"\")\n\nSolve power flow using an adaptive damped Newton-Raphson method.\n\nThis function implements a Newton-Raphson method with adaptive damping factor to improve convergence in difficult cases. The damping factor is automatically adjusted based on the mismatch norm during iterations.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix\ngen: Generator data matrix\nload: Load data matrix\npvarray: PV array data\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference bus index\np: Vector of bus indices\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Linear solver algorithm (optional)\n\nReturns\n\nV: Final voltage solution vector\nconverged: Boolean indicating convergence status\ni: Number of iterations performed\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow.currentinjectionpf","page":"PowerFlow API","title":"PowerFlow.currentinjectionpf","text":"currentinjectionpf(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=\"\")\n\nSolve power flow using the Current Injection method, particularly suitable for resistive networks.\n\nArguments\n\nbaseMVA: Base MVA for power system normalization\nbus: Matrix containing bus data\ngen: Matrix containing generator data\nload: Matrix containing load data\npvarray: Array of PV bus information\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference (slack) bus index\np: Array of PQ bus indices\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Algorithm variant (optional)\n\nReturns\n\nV: Final complex voltage vector solution\nconverged: Boolean indicating whether the algorithm converged\ni: Number of iterations performed\n\nDescription\n\nThis function implements the Current Injection power flow method, which is particularly effective for networks with high R/X ratios (resistive networks). The method works by:\n\nConverting power injections to current injections\nCalculating current mismatches\nSolving for voltage updates using the real part of the admittance matrix\nIterating until convergence or maximum iterations reached\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow.newtonpf","page":"PowerFlow API","title":"PowerFlow.newtonpf","text":"newtonpf(baseMVA::Float64, bus::Matrix{Float64}, gen::Matrix{Float64}, \n         Ybus::SparseArrays.SparseMatrixCSC{ComplexF64}, V0::Vector{ComplexF64}, \n         ref::Vector{Int}, pv::Vector{Int}, pq::Vector{Int}, \n         tol0::Float64, max_it0::Int, alg::String=\"bicgstab\")\n\nSolve AC power flow using Newton-Raphson method.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix\ngen: Generator data matrix\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference bus indices\npv: PV bus indices\npq: PQ bus indices\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Algorithm specification for linear solver (default: \"bicgstab\")\n\nReturns\n\nV: Final voltage vector solution\nconverged: Boolean indicating whether the algorithm converged\ni: Number of iterations performed\nnorm_history: Array of norm values for each iteration\n\nDescription\n\nThis function implements the Newton-Raphson method to solve AC power flow equations. It iteratively updates voltage magnitudes and angles until the power mismatch falls below the specified tolerance or the maximum number of iterations is reached.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow.newtonpf-2","page":"PowerFlow API","title":"PowerFlow.newtonpf","text":"newtonpf(baseMVA::Float64, bus::Matrix{Float64}, gen::Matrix{Float64}, \n    load::Matrix{Float64}, pvarray, Ybus::SparseArrays.SparseMatrixCSC{ComplexF64}, V0::Vector{ComplexF64}, \n    ref::Vector{Int}, pv::Vector{Int}, pq::Vector{Int}, \n    tol0::Float64, max_it0::Int, alg::String=\"bicgstab\")\n\nSolve AC power flow using Newton-Raphson method with load and PV array models.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix\ngen: Generator data matrix\nload: Load data matrix\npvarray: PV array data\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference bus indices\npv: PV bus indices\npq: PQ bus indices\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Algorithm specification for linear solver (default: \"bicgstab\")\n\nReturns\n\nV: Final voltage vector solution\nconverged: Boolean indicating whether the algorithm converged\ni: Number of iterations performed\nnorm_history: Array of norm values for each iteration\n\nDescription\n\nThis function implements the Newton-Raphson method to solve AC power flow equations with load and PV array models. It iteratively updates voltage magnitudes and angles until the power mismatch falls below the specified tolerance or the maximum number of iterations is reached.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#DC-Power-Flow-Algorithm","page":"PowerFlow API","title":"DC Power Flow Algorithm","text":"","category":"section"},{"location":"api/powerflow.html#PowerFlow.newtondcpf","page":"PowerFlow API","title":"PowerFlow.newtondcpf","text":"newtondcpf(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=\"\")\n\nSolve DC power flow using Newton's method.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix\ngen: Generator data matrix\nload: Load data matrix\npvarray: PV array data\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference bus index\np: Vector of indices for buses to be included in the calculation\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Algorithm specification for linear solver (optional)\n\nReturns\n\nV: Final voltage vector solution\nconverged: Boolean indicating whether the algorithm converged\ni: Number of iterations performed\n\nDescription\n\nThis function implements the Newton-Raphson method to solve DC power flow equations. It iteratively updates voltage values until the power mismatch falls below the specified tolerance or the maximum number of iterations is reached.\n\nThe algorithm:\n\nInitializes voltage values from the provided starting point\nCalculates initial power mismatches\nConstructs the Jacobian matrix for each iteration\nUpdates voltage values using Newton's method\nChecks convergence based on power mismatch norm\n\nNotes\n\nThe Jacobian matrix represents the partial derivatives of power with respect to voltage\nThis implementation handles both real power balance constraints\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow.newtondcpf_sp","page":"PowerFlow API","title":"PowerFlow.newtondcpf_sp","text":"newtondcpf_sp(baseMVA, bus, gen, load, pvarray, Ybus, V0, ref, p, tol0, max_it0, alg=\"\")\n\nSolve DC power flow using Newton's method with sparse matrices.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix\ngen: Generator data matrix\nload: Load data matrix\npvarray: PV array data\nYbus: Bus admittance matrix\nV0: Initial voltage vector\nref: Reference bus index\np: Vector of indices for buses to be included in the calculation\ntol0: Convergence tolerance\nmax_it0: Maximum number of iterations\nalg: Algorithm specification (optional)\n\nReturns\n\nV: Final voltage vector solution\nconverged: Boolean indicating whether the algorithm converged\ni: Number of iterations performed\n\nDescription\n\nThis function solves DC power flow using Newton's method. In DC systems,  power P = V * I, where I = G * V (G is the conductance matrix). The function  iteratively updates voltage magnitudes until the power mismatch falls below  the specified tolerance or the maximum number of iterations is reached.\n\nThe algorithm:\n\nInitializes voltage values from the provided starting point\nCalculates initial power mismatches\nConstructs the Jacobian matrix for each iteration\nUpdates voltage values using Newton's method\nChecks convergence based on power mismatch norm\n\nNotes\n\nFor DC systems, only active power is considered\nThe Jacobian matrix represents the partial derivatives of power with respect to voltage\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#Linear-Problem-Solution-Algorithm","page":"PowerFlow API","title":"Linear Problem Solution Algorithm","text":"","category":"section"},{"location":"api/powerflow.html#GPU-Acceleration","page":"PowerFlow API","title":"GPU Acceleration","text":"","category":"section"},{"location":"api/powerflow.html#Other-Functions","page":"PowerFlow API","title":"Other Functions","text":"","category":"section"},{"location":"api/powerflow.html#PowerFlow.calculate_pv_power-NTuple{4, Any}","page":"PowerFlow API","title":"PowerFlow.calculate_pv_power","text":"calculate_pv_power(pvarray, bus, Vm, baseMVA)\n\nCalculate power injection from PV arrays and its derivative with respect to voltage magnitude.\n\nArguments\n\npvarray: PV array data matrix with columns representing PV parameters\nbus: Bus data matrix with columns representing bus parameters\nVm: Vector of bus voltage magnitudes\nbaseMVA: Base MVA for the system\n\nReturns\n\nSpv: Vector of complex power injections from PV arrays\ndSpv_dVm: Sparse matrix of partial derivatives of PV power injections with respect to voltage magnitude\n\nDescription\n\nThis function calculates the power injection from PV arrays based on a modified power function model that accounts for the PV array characteristics including open circuit voltage, short circuit current, and maximum power point voltage. It also computes the derivatives of these injections with respect to bus voltage magnitudes, which are needed for power flow Jacobian calculations.\n\nThe PV model uses a modified power function with correction terms to better represent the current-voltage characteristics of PV panels: I = Isc * (1 - (V/Voc)^a)^b * (1 - c * ((V/Vmpp) - 1)^2)\n\nNotes\n\nOnly active PV arrays (PVINSERVICE > 0) are considered\nThe function maps PV arrays to their respective buses using the bus numbering\nPower output is converted to per-unit on system MVA base\nOnly real power (no reactive power) is considered for PV arrays\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.makeSbus","page":"PowerFlow API","title":"PowerFlow.makeSbus","text":"makeSbus(baseMVA, bus, gen, Vm, Sg=nothing, return_derivative=false)\n\nBuild the vector of complex bus power injections (simplified version without PV arrays).\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix with columns representing bus parameters\ngen: Generator data matrix with columns representing generator parameters\nVm: Vector of bus voltage magnitudes\n\nKeyword Arguments\n\nSg: Optional pre-computed generator complex power injections (default: nothing)\nreturn_derivative: Boolean indicating whether to return derivative of Sbus with respect to Vm (default: false)\n\nReturns\n\nIf return_derivative=false: Vector of complex bus power injections (Sbus)\nIf return_derivative=true: Sparse matrix of partial derivatives of power injections with respect to voltage magnitude (dSbus_dVm)\n\nDescription\n\nThis is a simplified version of the makeSbus function that does not include PV array contributions. It computes the vector of complex bus power injections (Sbus) for power flow analysis, accounting for ZIP load models and generator injections.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow.makeSbus-Tuple{Any, Any, Any, Any, Matrix{Float64}, Any}","page":"PowerFlow API","title":"PowerFlow.makeSbus","text":"makeSbus(baseMVA, bus, gen, Vm, load::Matrix{Float64}, pvarray; dc=false, Sg=nothing, return_derivative=false)\n\nBuild the vector of complex bus power injections, including PV array contributions.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix with columns representing bus parameters\ngen: Generator data matrix with columns representing generator parameters\nVm: Vector of bus voltage magnitudes\nload: Load data matrix with columns representing load parameters\npvarray: PV array data matrix with columns representing PV parameters\n\nKeyword Arguments\n\ndc: Boolean indicating whether to use DC power flow assumptions (default: false)\nSg: Optional pre-computed generator complex power injections (default: nothing)\nreturn_derivative: Boolean indicating whether to return derivative of Sbus with respect to Vm (default: false)\n\nReturns\n\nIf return_derivative=false: Vector of complex bus power injections (Sbus)\nIf return_derivative=true: Sparse matrix of partial derivatives of power injections with respect to voltage magnitude (dSbus_dVm)\n\nDescription\n\nThis function computes the vector of complex bus power injections (Sbus) for power flow analysis. It accounts for ZIP load models, generator injections, and PV array contributions.\n\nWhen return_derivative=true, it returns the partial derivatives of the power injections with respect to voltage magnitude, which is useful for power flow Jacobian calculations.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.Sd","page":"PowerFlow API","title":"PowerFlow.Sd","text":"Sd\n\nA mutable structure to store ZIP load model components.\n\nFields\n\nz: Complex vector representing constant impedance component of load\ni: Complex vector representing constant current component of load\np: Complex vector representing constant power component of load\n\nThis structure is used to store the components of the ZIP load model for efficient power flow calculations.\n\n\n\n\n\n","category":"type"},{"location":"api/powerflow.html#PowerFlow.makeSdzip-NTuple{5, Any}","page":"PowerFlow API","title":"PowerFlow.makeSdzip","text":"makeSdzip(baseMVA, bus, pw_1, pw_2, pw_3)\n\nCreate a ZIP load model structure from bus data and specified ZIP percentages.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix with columns representing bus parameters\npw_1: Vector of constant power percentages for active power\npw_2: Vector of constant current percentages for active power\npw_3: Vector of constant impedance percentages for active power\n\nReturns\n\nsd: An Sd structure containing the ZIP load model components\n\nDescription\n\nThis function creates a ZIP (constant impedance, constant current, constant power) load model for power flow calculations. It converts the load data from the bus matrix to per-unit values based on the system MVA base and the specified percentages for each component.\n\nThe function assumes that the same percentage distribution applies to both active and reactive power, so it uses the same percentages (pw1, pw2, pw_3) for both P and Q components.\n\nNotes\n\nAll power values are converted to per-unit on system MVA base\nPD and QD columns in bus represent the total active and reactive power demand\npw1, pw2, pw_3 represent the percentages of constant power, constant current, and constant impedance components\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.makeSdzip-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.makeSdzip","text":"makeSdzip(baseMVA, bus)\n\nCreate a ZIP load model structure from bus data with default constant power model.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix with columns representing bus parameters\n\nReturns\n\nsd: An Sd structure containing the ZIP load model components\n\nDescription\n\nThis is a simplified version of the makeSdzip function that assumes a constant power model (100% constant power, 0% constant current, 0% constant impedance).\n\nNotes\n\nAll power values are converted to per-unit on system MVA base\nPD and QD columns in bus represent the total active and reactive power demand\nBy default, all load is modeled as constant power (P-Q) load\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.makeYbus-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"PowerFlow.makeYbus","text":"makeYbus(baseMVA, bus, branch)\n\nBuild the bus admittance matrix and branch admittance matrices.\n\nArguments\n\nbaseMVA: Base MVA for the system\nbus: Bus data matrix with columns representing bus parameters\nbranch: Branch data matrix with columns representing branch parameters\n\nReturns\n\nYbus: Bus admittance matrix\nYf: Branch admittance matrix for \"from\" end of branches\nYt: Branch admittance matrix for \"to\" end of branches\n\nDescription\n\nThis function builds the bus admittance matrix (Ybus) and branch admittance matrices (Yf and Yt) for a given power system network. The admittance matrices are essential components for power flow and other power system analyses.\n\nThe function:\n\nComputes branch series admittances and line charging susceptances\nHandles tap ratios and phase shifters\nIncorporates bus shunt admittances\nBuilds connection matrices between branches and buses\nConstructs the complete bus admittance matrix\n\nNotes\n\nAll admittance values are in per-unit on system MVA base\nRequires buses to be numbered consecutively (internal ordering)\nBranch status values determine which branches are in service\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.merge_results-Tuple{Any}","page":"PowerFlow API","title":"PowerFlow.merge_results","text":"merge_results(results)\n\nMerge power flow calculation results from multiple isolated islands.\n\nArguments\n\nresults: An array of JPC objects containing power flow results for different islands\n\nReturns\n\nmerged_result: A single JPC object containing the combined results\narea: The number of islands that were merged\n\nDescription\n\nThis function combines power flow results from multiple isolated islands into a single comprehensive result. It merges all data matrices (buses, branches, generators, etc.) from the individual island results and sorts them by their ID numbers.\n\nThe function:\n\nCreates a new JPC object to hold the merged results\nCombines basic result fields like success status and iteration counts\nMerges all data matrices from the input results\nSorts the merged matrices by their first column (typically ID numbers)\n\nNotes\n\nAssumes all input results use the same base MVA\nSuccess is determined by the logical AND of all individual results' success flags\nIteration count is the maximum of all individual results' iteration counts\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.extract_bus_data-Tuple{Utils.JPC}","page":"PowerFlow API","title":"PowerFlow.extract_bus_data","text":"Extract bus data from your data structure\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.generate_matpower_report","page":"PowerFlow API","title":"PowerFlow.generate_matpower_report","text":"Format power flow calculation results as MATPOWER-style report and save to a text file\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow.write_branch_data-Tuple{IOStream, Utils.JPC}","page":"PowerFlow API","title":"PowerFlow.write_branch_data","text":"Write branch data section\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.write_bus_data-Tuple{IOStream, Utils.JPC, Any}","page":"PowerFlow API","title":"PowerFlow.write_bus_data","text":"Write bus data section\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.write_system_summary-Tuple{IOStream, Utils.JPC, Any, Any}","page":"PowerFlow API","title":"PowerFlow.write_system_summary","text":"Write system summary section\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.dcpfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 6}}","page":"PowerFlow API","title":"PowerFlow.dcpfsoln","text":"dcpfsoln(baseMVA::Float64, bus0::Matrix{Float64}, gen0::Matrix{Float64}, \n         branch0::Matrix{Float64}, load0::Matrix{Float64}, Ybus, Yf, Yt, V, ref, p)\n\nUpdate power system state variables after a DC power flow solution.\n\nArguments\n\nbaseMVA::Float64: Base MVA value for the system\nbus0::Matrix{Float64}: Initial bus data matrix\ngen0::Matrix{Float64}: Initial generator data matrix\nbranch0::Matrix{Float64}: Initial branch data matrix\nload0::Matrix{Float64}: Load data matrix\nYbus: Bus admittance matrix\nYf: From-bus branch admittance matrix\nYt: To-bus branch admittance matrix\nV: Complex bus voltage vector solution\nref: Reference (slack) bus indices\np: P bus indices\n\nReturns\n\nbus: Updated bus data matrix\ngen: Updated generator data matrix\nbranch: Updated branch data matrix with power flows\n\nDescription\n\nThis function updates the power system state variables after a DC power flow solution has been obtained. It performs the following operations:\n\nUpdates bus voltage magnitudes\nUpdates generator reactive power (Qg) for generators at PV and slack buses\nDistributes reactive power proportionally among multiple generators at the same bus\nRespects generator reactive power limits\nUpdates active power (Pg) for generators at slack buses\nCalculates branch power flows\nExpands the branch matrix if needed to store power flow results\n\nThe function handles special cases like multiple generators at the same bus and generators with identical reactive power limits.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.pfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 7}}","page":"PowerFlow API","title":"PowerFlow.pfsoln","text":"Update power flow solution with computed voltage values and calculate generator outputs and branch flows. For the version with load data as a separate parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.pfsoln-Tuple{Float64, Matrix{Float64}, Matrix{Float64}, Matrix{Float64}, Vararg{Any, 7}}","page":"PowerFlow API","title":"PowerFlow.pfsoln","text":"Update power flow solution with computed voltage values and calculate generator outputs and branch flows. Standard version without separate load data parameter.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.process_result-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"PowerFlow.process_result","text":"Process power flow calculation results and generate a report. This function merges results, extracts execution time, and creates a MATPOWER format report.\n\nParameters:\n\nresults: Array containing calculation results and timing information\nisolated: Information about isolated parts of the network\nfile_path: Path where the report will be saved\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.analyze_voltage_results-Tuple{NamedTuple, Utils.JuliaPowerCase, String}","page":"PowerFlow API","title":"PowerFlow.analyze_voltage_results","text":"analyze_voltage_results(results::NamedTuple, case::JuliaPowerCase, reference_file::String;\n                       tolerance_mag::Float64=1e-4, tolerance_ang::Float64=1e-3,\n                       output_dir::String=\"./results\")\n\nAnalyze voltage differences between power flow calculation results and reference file, generate comparison reports and charts. Supports both original format and AC/DC mixed format. Parameters:\n\nresults: NamedTuple containing results in JPC format (typically the return value of power flow calculation)\ncase: Original JuliaPowerCase object, used to get node names and ID mappings\nreference_file: Path to Excel file containing reference voltage values\ntolerance_mag: Tolerance for voltage magnitude comparison (default: 1e-4)\ntolerance_ang: Tolerance for voltage angle comparison (default: 1e-3)\noutput_dir: Output directory (default: \"./results\")\n\nReturns:\n\nDataFrame or NamedTuple containing comparison results\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.compare_voltage_results-Tuple{NamedTuple, Utils.JuliaPowerCase, String}","page":"PowerFlow API","title":"PowerFlow.compare_voltage_results","text":"compare_voltage_results(results::NamedTuple, case::JuliaPowerCase, reference_file::String; \n                       tolerance_mag::Float64=1e-4, tolerance_ang::Float64=1e-3)\n\nCompare power flow calculation results in JPC format with reference voltage values, using JuliaPowerCase for node mapping. Supports both original format and new format with mixed AC/DC data. Parameters:\n\nresults: NamedTuple containing results in JPC format (typically the return value of power flow calculation)\ncase: Original JuliaPowerCase object, used to get node names and ID mappings\nreference_file: Path to Excel file containing reference voltage values\ntolerance_mag: Tolerance for voltage magnitude comparison (default: 1e-4)\ntolerance_ang: Tolerance for voltage angle comparison (default: 1e-3)\n\nReturns:\n\nNamedTuple containing comparison results, including ac and dc DataFrames\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_bus_voltage_results-Tuple{NamedTuple, Utils.JuliaPowerCase}","page":"PowerFlow API","title":"PowerFlow.get_bus_voltage_results","text":"get_bus_voltage_results(results::NamedTuple, case::JuliaPowerCase)\n\nExtract bus voltage information from power flow calculation results in JPC format, and map to node names in JuliaPowerCase. Parameters:\n\nresults: NamedTuple containing results in JPC format (typically the return value of power flow calculation)\ncase: Original JuliaPowerCase object, used to get node names and ID mappings\n\nReturns:\n\nDataFrame containing bus voltage results\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_bus_voltage_results_acdc-Tuple{NamedTuple, Utils.JuliaPowerCase}","page":"PowerFlow API","title":"PowerFlow.get_bus_voltage_results_acdc","text":"get_bus_voltage_results_acdc(results::NamedTuple, case::JuliaPowerCase)\n\nExtract both AC and DC bus voltage information from power flow calculation results in JPC format, and map to node names in JuliaPowerCase. Parameters:\n\nresults: NamedTuple containing results in JPC format (typically the return value of power flow calculation)\ncase: Original JuliaPowerCase object, used to get node names and ID mappings\n\nReturns:\n\nNamedTuple containing AC and DC bus voltage results as two DataFrames: ac and dc\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.plot_voltage_comparison","page":"PowerFlow API","title":"PowerFlow.plot_voltage_comparison","text":"plot_voltage_comparison(comparison_results, output_file::String=\"voltage_comparison.png\";\n                       show_plot::Bool=true)\n\nPlot voltage magnitude and angle comparison curves between calculated and reference values. Supports both original format and AC/DC mixed format. Parameters:\n\ncomparison_results: Can be a DataFrame or a NamedTuple containing ac and dc DataFrames\noutputfile: Path to save the chart file (default: \"voltagecomparison.png\")\nshow_plot: Whether to display the chart (default: true)\n\nReturns:\n\nGenerated chart object or NamedTuple containing chart objects\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow.plot_voltage_errors","page":"PowerFlow API","title":"PowerFlow.plot_voltage_errors","text":"plot_voltage_errors(comparison_results, output_file::String=\"voltage_errors.png\";\n                   show_plot::Bool=true)\n\nPlot voltage magnitude and angle error curves. Supports both original format and AC/DC mixed format. Parameters:\n\ncomparison_results: Can be a DataFrame or a NamedTuple containing ac and dc DataFrames\noutputfile: Path to save the chart file (default: \"voltageerrors.png\")\nshow_plot: Whether to display the chart (default: true)\n\nReturns:\n\nGenerated chart object or NamedTuple containing chart objects\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow.save_comparison_results-Tuple{Any, String}","page":"PowerFlow API","title":"PowerFlow.save_comparison_results","text":"save_comparison_results(comparison_results, output_file::String)\n\nSave comparison results to an Excel file. Supports both original format and AC/DC mixed format. Parameters:\n\ncomparison_results: Can be a DataFrame or a NamedTuple containing ac and dc DataFrames\noutput_file: Output file path\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.rundcpf-Tuple{Any, Dict{String}}","page":"PowerFlow API","title":"PowerFlow.rundcpf","text":"Main function to call the DC power flow function     Input: case file     Output: results of the power flow as a dictionary     Example:     bus, gen, branch = rundcpf(casefile)\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.calculate_droop_voltage","page":"PowerFlow API","title":"PowerFlow.calculate_droop_voltage","text":"calculate_droop_voltage(P_dc, k_p, U_dc_ref=1.0, U_dc_min=0.95, U_dc_max=1.05)\n\nCalculate DC voltage with droop control using the equation: Udc = Udcref - kp * P_dc Limits the output voltage to be within specified minimum and maximum values.\n\nParameters:\n\nP_dc: DC power\nk_p: Droop coefficient\nUdcref: Reference DC voltage (default: 1.0 p.u.)\nUdcmin: Minimum allowed DC voltage (default: 0.95 p.u.)\nUdcmax: Maximum allowed DC voltage (default: 1.05 p.u.)\n\nReturns:\n\nLimited DC voltage value\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow.runhpf-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.runhpf","text":"runhpf(jpc, opt)\n\nRun hybrid power flow calculation for integrated AC/DC systems. Iteratively solves AC and DC power flow while updating converter power exchanges. Supports different converter control modes.\n\nParameters:\n\njpc: JPC object containing both AC and DC system data\nopt: Options for power flow calculation\n\nReturns:\n\nUpdated JPC object with power flow results\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.update_ac_load!-NTuple{4, Any}","page":"PowerFlow API","title":"PowerFlow.update_ac_load!","text":"update_ac_load!(result_jpc, jpc1, ac_bus_id, P_ac)\n\nHelper function to update AC side load with power from converter. Creates a new load if none exists at the specified bus.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\nacbusid: ID of the AC bus to update\nP_ac: AC power to add to the load\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.update_dc_load!-NTuple{4, Any}","page":"PowerFlow API","title":"PowerFlow.update_dc_load!","text":"update_dc_load!(result_jpc, jpc2, dc_bus_id, P_dc)\n\nHelper function to update DC side load with power from converter. Creates a new load if none exists at the specified bus.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc2: JPC object for DC system\ndcbusid: ID of the DC bus to update\nP_dc: DC power to add to the load\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.update_mode_1_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"PowerFlow.update_mode_1_converters!","text":"update_mode_1_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode constant δs, Us (CONV_MODE==1). These converters have fixed AC voltage angle and magnitude, and the power is calculated from AC side.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.update_mode_3_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"PowerFlow.update_mode_3_converters!","text":"update_mode_3_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode constant Ps, Us (CONV_MODE==3). These converters have fixed active power and AC voltage magnitude.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.update_mode_4_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"PowerFlow.update_mode_4_converters!","text":"update_mode_4_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode constant Udc, Qs (CONV_MODE==4). These converters have fixed DC voltage and reactive power.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.update_mode_5_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"PowerFlow.update_mode_5_converters!","text":"update_mode_5_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode constant Udc, Us (CONV_MODE==5). These converters have fixed DC voltage and AC voltage magnitude.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.update_mode_6_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"PowerFlow.update_mode_6_converters!","text":"update_mode_6_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode Droop Udc, Constant Qs (CONV_MODE==6). These converters use DC voltage droop control and maintain constant reactive power.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.update_mode_7_converters!-NTuple{4, Any}","page":"PowerFlow API","title":"PowerFlow.update_mode_7_converters!","text":"update_mode_7_converters!(result_jpc, jpc1, jpc2, current_power_values)\n\nUpdate converters with mode Droop Udc, Constant Us (CONV_MODE==7). These converters use DC voltage droop control and maintain constant AC voltage magnitude.\n\nParameters:\n\nresult_jpc: Main JPC object containing all system data\njpc1: JPC object for AC system\njpc2: JPC object for DC system\ncurrentpowervalues: Dictionary to store current power values for convergence check\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.I0_from_V012-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.I0_from_V012","text":"I0_from_V012(V012, Y)\n\nCalculate zero sequence current from sequence voltages and admittance matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.I1_from_V012-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.I1_from_V012","text":"I1_from_V012(V012, Y)\n\nCalculate positive sequence current from sequence voltages and admittance matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.I2_from_V012-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.I2_from_V012","text":"I2_from_V012(V012, Y)\n\nCalculate negative sequence current from sequence voltages and admittance matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.I_from_SV_elementwise-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.I_from_SV_elementwise","text":"I_from_SV_elementwise(S, V)\n\nCalculate current from complex power and voltage: I = conj(S/V).\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.SVabc_from_SV012-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.SVabc_from_SV012","text":"SVabc_from_SV012(S012, V012; n_res=nothing, idx=nothing)\n\nConvert sequence components of power and voltage to phase components.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.S_from_VI_elementwise-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.S_from_VI_elementwise","text":"S_from_VI_elementwise(v, i)\n\nCalculate complex power from voltage and current: S = V * conj(I).\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.V1_from_jpc-Tuple{Any}","page":"PowerFlow API","title":"PowerFlow.V1_from_jpc","text":"V1_from_jpc(jpc)\n\nExtract positive sequence voltage from JPC structure.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.V_from_I-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.V_from_I","text":"V_from_I(Y, I)\n\nCalculate voltage from current using V = Y\\I.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow._clean_up","page":"PowerFlow API","title":"PowerFlow._clean_up","text":"_clean_up(net, res=true)\n\nClean up temporary data structures after power flow calculation.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow._get_p_q_gen_results_3ph-NTuple{5, Any}","page":"PowerFlow API","title":"PowerFlow._get_p_q_gen_results_3ph","text":"_get_p_q_gen_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2)\n\nCalculate active and reactive power for generators in three-phase system.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow._sum_by_group_nvals-Tuple{Any, Vararg{Any}}","page":"PowerFlow API","title":"PowerFlow._sum_by_group_nvals","text":"_sum_by_group_nvals(bus, vals...)\n\nGroup values by bus and sum them within each group for multiple value arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.combine_X012-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"PowerFlow.combine_X012","text":"combine_X012(X0, X1, X2)\n\nCombine zero, positive, and negative sequence components into one matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.current_from_voltage_results-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"PowerFlow.current_from_voltage_results","text":"current_from_voltage_results(y_0_pu, y_1_pu, v_012_pu)\n\nCalculate sequence currents from sequence voltages and admittance matrices.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.extratct_jpc_3ph-Tuple{Utils.JPC_3ph}","page":"PowerFlow API","title":"PowerFlow.extratct_jpc_3ph","text":"extratct_jpc_3ph(jpc_3ph::PowerFlow.JPC_3ph)\n\nExtract individual sequence components from a three-phase JPC object.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_branch_flows_3ph-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"PowerFlow.get_branch_flows_3ph","text":"get_branch_flows_3ph(jpc0, jpc1, jpc2)\n\nCalculate branch flows for three-phase system.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_branch_results_3ph-NTuple{5, Any}","page":"PowerFlow API","title":"PowerFlow.get_branch_results_3ph","text":"get_branch_results_3ph(jpc_3ph, jpc0, jpc1, jpc2, pq_buses)\n\nExtract branch results and write them to the appropriate dataframes.\n\nParameters:     results: result of runpf loadflow calculation     p: dict to store \"resline\" and \"restrafo\" Dataframes\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_bus_results_3ph-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"PowerFlow.get_bus_results_3ph","text":"get_bus_results_3ph(case, jpc_3ph, bus_pq)\n\nStore three-phase bus results in the appropriate fields.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_bus_v_results_3ph-NTuple{4, Any}","page":"PowerFlow API","title":"PowerFlow.get_bus_v_results_3ph","text":"get_bus_v_results_3ph(jpc_3ph, jpc0, jpc1, jpc2)\n\nCalculate and store three-phase voltage results for all buses.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_elements-Tuple{Any, Utils.JuliaPowerCase, Any, Any, Any}","page":"PowerFlow API","title":"PowerFlow.get_elements","text":"get_elements(params, case::JuliaPowerCase, element, phase, typ)\n\nThis function is used to get the elements of the load mapping. Automatically skips elements that don't exist in case.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_ext_grid_results_3ph-NTuple{5, Any}","page":"PowerFlow API","title":"PowerFlow.get_ext_grid_results_3ph","text":"get_ext_grid_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2)\n\nCalculate and store three-phase external grid results.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_full_branch_zero-Tuple{Any}","page":"PowerFlow API","title":"PowerFlow.get_full_branch_zero","text":"get_full_branch_zero(jpc_3ph)\n\nAdd non-service branches to zero sequence branch data.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_gen_results_3ph-NTuple{6, Any}","page":"PowerFlow API","title":"PowerFlow.get_gen_results_3ph","text":"get_gen_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2, pq_bus)\n\nCalculate and store three-phase generator results.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_internal_variables-Tuple{Utils.JPC}","page":"PowerFlow API","title":"PowerFlow.get_internal_variables","text":"get_internal_variables(jpc::JPC)\n\nRetrieve stored internal variables for a JPC object.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_p_q_b","page":"PowerFlow API","title":"PowerFlow.get_p_q_b","text":"get_p_q_b(case, jpc_3ph, element, suffix=nothing)\n\nGet active and reactive power values and bus indices for a specific element.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow.get_p_q_b_3ph-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.get_p_q_b_3ph","text":"get_p_q_b_3ph(net, element)\n\nGet three-phase active and reactive power values and bus indices for a specific element.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_p_q_results_3ph-Tuple{Any, Utils.JPC_3ph}","page":"PowerFlow API","title":"PowerFlow.get_p_q_results_3ph","text":"get_p_q_results_3ph(case, jpc_3ph::PowerFlow.JPC_3ph)\n\nCalculate and aggregate active and reactive power results for three-phase system.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_pf_variables_from_JPC-Tuple{Utils.JPC}","page":"PowerFlow API","title":"PowerFlow.get_pf_variables_from_JPC","text":"get_pf_variables_from_JPC(jpc::JPC)\n\nExtract power flow variables from JPC structure.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_pp_gen_results_3ph-NTuple{12, Any}","page":"PowerFlow API","title":"PowerFlow.get_pp_gen_results_3ph","text":"get_pp_gen_results_3ph(case, jpc_3ph, jpc0, jpc1, jpc2, b, pA, qA, pB, qB, pC, qC)\n\nCalculate and store three-phase generator results.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.get_y_bus-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"PowerFlow.get_y_bus","text":"get_y_bus(jpc0, jpc1, jpc2)\n\nBuild admittance matrices for zero, positive, and negative sequence networks.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.load_mapping-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"PowerFlow API","title":"PowerFlow.load_mapping","text":"load_mapping(case::JuliaPowerCase, jpc1::JPC)\n\nMaps loads from the case to the power flow model, handling both wye and delta connections for all three phases.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.phase_shift_unit_operator-Tuple{Any}","page":"PowerFlow API","title":"PowerFlow.phase_shift_unit_operator","text":"phase_shift_unit_operator(angle_deg)\n\nCreate a complex number representing a phase shift of the given angle in degrees.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.phase_to_sequence-Tuple{Any}","page":"PowerFlow API","title":"PowerFlow.phase_to_sequence","text":"phase_to_sequence(Xabc)\n\nTransform phase components (a, b, c) to sequence components (zero, positive, negative).\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.robust_process-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.robust_process","text":"robust_process(net, jpc)\n\nProcess network and JPC data to ensure robust operation.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.run_newton_raphson_pf-Tuple{Utils.JPC, Any}","page":"PowerFlow API","title":"PowerFlow.run_newton_raphson_pf","text":"run_newton_raphson_pf(jpc::JPC, opt)\n\nRun Newton-Raphson power flow calculation.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.runupf-NTuple{5, Any}","page":"PowerFlow API","title":"PowerFlow.runupf","text":"runupf(case, jpc_3ph, gs_eg, bs_eg, opt)\n\nThis function is used to run a local unbalanced power flow analysis on unsymmetrical load nodes\n\n#Step1: find the unbalanced nodes in the system #Step2: find the interface branches of the unbalanced nodes and balanced nodes\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.sequence_to_phase-Tuple{Any}","page":"PowerFlow API","title":"PowerFlow.sequence_to_phase","text":"sequence_to_phase(X012)\n\nTransform sequence components (zero, positive, negative) to phase components (a, b, c).\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.sum_by_group-Tuple{Any, Any, Any}","page":"PowerFlow API","title":"PowerFlow.sum_by_group","text":"sum_by_group(bus, first_val, second_val)\n\nGroup values by bus and sum them within each group.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.write_pq_results_to_element","page":"PowerFlow API","title":"PowerFlow.write_pq_results_to_element","text":"write_pq_results_to_element(case, jpc_3ph, element, suffix=nothing)\n\nWrite power results to the specified element in jpc_3ph.\n\n\n\n\n\n","category":"function"},{"location":"api/powerflow.html#PowerFlow.write_pq_results_to_element_3ph-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.write_pq_results_to_element_3ph","text":"write_pq_results_to_element_3ph(net, element)\n\nGet pmw and qmvar for a specific pq element (\"load\", \"sgen\"...). This function basically writes values from element table to res_element table.\n\nParameters:     net: pandapower network     element: element name (str) Returns:     net with updated results\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.total_load-Tuple{Any, Any}","page":"PowerFlow API","title":"PowerFlow.total_load","text":"total_load(bus, load)\n\nCalculate the total fixed and dispatchable load at each bus in the system, considering ZIP load model.\n\nArguments\n\nbus: Bus data matrix containing bus information\nload: Load data matrix containing load model percentages\n\nReturns\n\nPd: Vector of real power demand at each bus\nQd: Vector of reactive power demand at each bus (if want_Q=1)\n\nThis function computes the total load at each bus using the ZIP load model, which represents loads as a combination of constant impedance (Z), constant current (I), and constant power (P) components. The percentages for each component are specified in the load matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/powerflow.html#PowerFlow.total_load-Tuple{Any}","page":"PowerFlow API","title":"PowerFlow.total_load","text":"total_load(bus)\n\nCalculate the total fixed and dispatchable load at each bus in the system using default ZIP parameters.\n\nArguments\n\nbus: Bus data matrix containing bus information\n\nReturns\n\nPd: Vector of real power demand at each bus\nQd: Vector of reactive power demand at each bus (if want_Q=1)\n\nThis is an overloaded version of total_load that uses default ZIP model parameters. It computes the total load at each bus using the standard ZIP load model with default percentages for constant impedance (Z), constant current (I), and constant power (P) components.\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#API-Reference","page":"Utils API","title":"API Reference","text":"","category":"section"},{"location":"api/utils.html#Input-Interface","page":"Utils API","title":"Input Interface","text":"","category":"section"},{"location":"api/utils.html#Utils.load_ac_pv_system!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_ac_pv_system!","text":"load_ac_pv_system!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad AC PV system data from Excel file and add to power system case. Parameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing AC PV system data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_buses!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_buses!","text":"load_buses!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad bus data from Excel file and add to power system case. Also creates mappings from bus names to integer IDs and from zone names to integer IDs.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing bus data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_converters!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_converters!","text":"load_converters!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad converter data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing converter data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_dclines!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_dclines!","text":"load_dclines!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad DC line data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing DC line data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_dcloads!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_dcloads!","text":"load_dcloads!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad DC load data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing DC load data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_ext_grids!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_ext_grids!","text":"load_ext_grids!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad external grid data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing external grid data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_generators!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_generators!","text":"load_generators!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad generator data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing generator data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_julia_power_data-Tuple{String}","page":"Utils API","title":"Utils.load_julia_power_data","text":"load_julia_power_data(file_path::String)\n\nLoad power system data from an Excel file and convert it to a JuliaPowerCase structure.\n\nParameters:\n\nfile_path::String: Path to the Excel file\n\nReturns:\n\nJuliaPowerCase: Structure containing all power system components\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_lines!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_lines!","text":"load_lines!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad line data from Excel file and add to power system case. Uses case.busnameto_id to map bus names to integer IDs.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing line data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_loads!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_loads!","text":"load_loads!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad load data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing load data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_pv_arrays!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_pv_arrays!","text":"load_pv_arrays!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad PV array data from Excel file and add to power system case. Parameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing PV array data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_static_generators!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_static_generators!","text":"load_static_generators!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad static generator data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing static generator data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_storages!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_storages!","text":"load_storages!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad energy storage device data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing energy storage device data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_switches!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_switches!","text":"load_switches!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad switch data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing switch data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_trafo!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_trafo!","text":"load_trafo!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad two-winding transformer data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing two-winding transformer data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_trafo3ws!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_trafo3ws!","text":"load_trafo3ws!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad three-winding transformer data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing three-winding transformer data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.load_virtual_power_plants!-Tuple{Utils.JuliaPowerCase, String, String}","page":"Utils API","title":"Utils.load_virtual_power_plants!","text":"load_virtual_power_plants!(case::JuliaPowerCase, file_path::String, sheet_name::String)\n\nLoad virtual power plant (VPP) data from Excel file and add to power system case.\n\nParameters:\n\ncase::JuliaPowerCase: Power system case\nfile_path::String: Excel file path\nsheet_name::String: Worksheet name containing virtual power plant data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.validate_case-Tuple{Utils.JuliaPowerCase}","page":"Utils API","title":"Utils.validate_case","text":"validate_case(case::JuliaPowerCase)\n\nValidate the integrity and consistency of the loaded power system case data.\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.convert_matpower_case-Tuple{Any, Any}","page":"Utils API","title":"Utils.convert_matpower_case","text":"convert_matpower_case(input_filepath, output_filepath)\n\nConvert a MATPOWER case file from MATLAB format to Julia format. This function handles the entire conversion process, including parsing the MATLAB file, converting the data structures, and saving the result as a Julia file.\n\nArguments\n\ninput_filepath::String: Path to the input MATLAB case file\noutput_filepath::String: Path where the output Julia file should be saved\n\nReturns\n\nDict{String, Any} or nothing: The parsed case data if successful, nothing if an error occurs\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.parse_matlab_case_file-Tuple{Any}","page":"Utils API","title":"Utils.parse_matlab_case_file","text":"parse_matlab_case_file(filepath)\n\nParse a MATPOWER case file in MATLAB format and convert it to a Julia dictionary. The function extracts baseMVA, version, and all matrix data from the file.\n\nArguments\n\nfilepath::String: Path to the MATLAB case file\n\nReturns\n\nDict{String, Any}: Dictionary containing all parsed data from the case file\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.save_to_julia_file-Tuple{Any, Any}","page":"Utils API","title":"Utils.save_to_julia_file","text":"save_to_julia_file(mpc, output_filepath)\n\nSave a parsed MATPOWER case as a Julia file with a function that returns the data.\n\nArguments\n\nmpc::Dict{String, Any}: Dictionary containing the parsed MATPOWER case data\noutput_filepath::String: Path where the Julia file should be saved\n\nReturns\n\nNothing, but creates a Julia file at the specified location\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Data-Structure","page":"Utils API","title":"Data Structure","text":"","category":"section"},{"location":"api/utils.html#Utils.JPC","page":"Utils API","title":"Utils.JPC","text":"Definition of the JPC structure as one matrix format.\nThis structure represents a power system case in a one matrix format,\nincluding buses, generators, branches, loads, and other power system components.\nEach matrix is sized according to the number of attributes defined in idx.jl.\n\n\n\n\n\n","category":"type"},{"location":"api/utils.html#Utils.JPC_3ph","page":"Utils API","title":"Utils.JPC_3ph","text":"Definition of the JPC_3ph structure for three-phase power flow analysis.\nThis structure extends the JPC format to support three-phase power flow calculations.\n\n\n\n\n\n","category":"type"},{"location":"api/utils.html#Utils.JuliaPowerCase","page":"Utils API","title":"Utils.JuliaPowerCase","text":"Definition of the power flow problem structure.\nAligned with JPC structure for consistency.\n\n\n\n\n\n","category":"type"},{"location":"api/utils.html#Utils.MicrogridPlanningProblem","page":"Utils API","title":"Utils.MicrogridPlanningProblem","text":"Definition of the Microgrid Planning Problem structure.    This structure contains all parameters and variables for microgrid planning optimization.\n\n\n\n\n\n","category":"type"},{"location":"api/utils.html#Base.getindex-Tuple{Utils.JPC, String}","page":"Utils API","title":"Base.getindex","text":"getindex(jpc::JPC, key::String)\n\nAccess JPC components by string key.\n\nArguments\n\njpc: JPC structure\nkey: String key representing the component to access\n\nReturns\n\nThe requested component data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Base.getindex-Tuple{Utils.JPC_3ph, String}","page":"Utils API","title":"Base.getindex","text":"getindex(jpc::JPC_3ph, key::String)\n\nAccess JPC_3ph components by string key.\n\nArguments\n\njpc: JPC_3ph structure\nkey: String key representing the component to access\n\nReturns\n\nThe requested component data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Base.setindex!-Tuple{Utils.JPC, Any, String}","page":"Utils API","title":"Base.setindex!","text":"setindex!(jpc::JPC, value, key::String)\n\nSet JPC components by string key.\n\nArguments\n\njpc: JPC structure\nvalue: Value to assign\nkey: String key representing the component to modify\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Base.setindex!-Tuple{Utils.JPC_3ph, Any, String}","page":"Utils API","title":"Base.setindex!","text":"setindex!(jpc::JPC_3ph, value, key::String)\n\nSet JPC_3ph components by string key.\n\nArguments\n\njpc: JPC_3ph structure\nvalue: Value to assign\nkey: String key representing the component to modify\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Inner-Interface","page":"Utils API","title":"Inner Interface","text":"","category":"section"},{"location":"api/utils.html#Utils.JPC_ac_pv_system_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_ac_pv_system_process","text":"JPC_ac_pv_system_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses AC-side photovoltaic (PV) systems from a JuliaPowerCase and converts them to JPC format.\n\nThis function extracts information about AC-connected PV systems from the input case, performs necessary calculations to determine their electrical characteristics, and stores the processed data in the JPC structure.\n\nFor each AC-side PV system, the function:\n\nCalculates operating voltages and currents based on panel configuration and conditions:\nMaximum power point voltage (Vmpp) adjusted for series-connected panels\nOpen-circuit voltage (Voc) adjusted for temperature and series connections\nShort-circuit current (Isc) adjusted for temperature, irradiance, and parallel connections\nMaximum power point current (Impp) adjusted for parallel-connected panels\nCalculates maximum power output accounting for system losses\nDetermines the control mode (Voltage Control or MVar Control)\nStores all parameters in a standardized matrix format\n\nThe function performs the following steps:\n\nFilters the input case to identify in-service AC-side PV systems\nIf no in-service systems exist, returns the JPC object unchanged\nCreates a matrix to store PV system data\nFor each PV system:\nCalculates electrical parameters based on environmental conditions\nSets control mode flags\nPopulates the matrix with all required parameters\nAdds the processed PV system data to the JPC object's pv_acsystem field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing AC-side PV system data\njpc::JPC: The JPC object where the processed PV system data will be stored\n\nReturns\n\nThe updated JPC object with AC-side PV system data in the pv_acsystem field\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_battery_branch_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_battery_branch_process","text":"JPC_battery_branch_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses battery storage branches from a JuliaPowerCase and converts them to JPC format.\n\nThis function creates DC branch connections between virtual battery buses and their  corresponding actual buses in the power system. Each battery is represented as a DC branch with the following characteristics:\n\nFrom bus: Virtual battery bus (created in JPCbatterybus_process)\nTo bus: Actual bus where the battery is physically connected\nBranch resistance: Calculated from battery internal resistance in per unit\nBranch reactance: Set to 0 (DC branches have no reactance)\nBranch rating: Based on battery package size and open-circuit voltage\nBranch status: 1.0 if in service, 0.0 if not\nAngle limits: Set to -360° and 360°\n\nThe function performs the following steps:\n\nCreates a deep copy of the battery storage data\nIf no batteries exist, returns the JPC object unchanged\nInitializes a matrix to store battery branch data\nFor each battery:\nIdentifies the actual bus where the battery is connected\nCalculates the virtual bus ID for the battery\nRetrieves the base voltage from the actual bus\nCalculates the per unit resistance using the base impedance\nSets all branch parameters including status and ratings\nAppends the processed battery branch data to the JPC object's branchDC field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing battery storage data\njpc::JPC: The JPC object where the battery branch data will be added\n\nReturns\n\nThe updated JPC object with battery branches added to the branchDC field\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_battery_bus_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_battery_bus_process","text":"JPC_battery_bus_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses battery storage data from a JuliaPowerCase and creates virtual DC buses for them in the JPC format.\n\nThis function extracts battery storage information from the input case, creates virtual DC buses to represent the batteries in the power system model, and appends these buses to the existing DC bus matrix in the JPC object.\n\nEach battery is represented as a virtual DC bus with the following characteristics:\n\nBus ID assigned sequentially after existing DC buses\nBus type set to PV node (value 2.0)\nNo initial power demand or generation\nVoltage magnitude initialized to 1.0 p.u.\nVoltage angle initialized to 0.0 degrees\nBase voltage set to the battery's open-circuit voltage\nArea and zone IDs set to 1.0\nVoltage limits set to 0.95 (min) and 1.05 (max) p.u.\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing battery storage data\njpc::JPC: The JPC object where the virtual battery buses will be added\n\nReturns\n\nThe updated JPC object with virtual battery buses added to the busDC field\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_battery_gens_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_battery_gens_process","text":"JPC_battery_gens_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess battery storage devices and create virtual generators for them in the JPC structure.\n\nThis function creates virtual generators to represent battery storage devices in the power system model. Each battery is assigned a virtual bus and corresponding generator parameters based on its characteristics.\n\nThe function performs the following steps:\n\nMakes a deep copy of the storage devices from the input case\nIf no batteries exist, returns without modifications\nDetermines virtual node numbers based on the current busDC matrix size\nCreates matrices for battery generators and storage information\nFor each battery:\nAssigns a virtual bus number\nCalculates power capacity based on battery parameters\nSets generator parameters (power limits, voltage setpoint, status, etc.)\nConfigures storage-specific parameters\nAdds the battery generators to the JPC's genDC field\nAdds the storage information to the JPC's storageetap field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing battery storage data\njpc::JPC: The JPC object where the virtual generators will be added\n\nReturns\n\nThe updated JPC object with battery virtual generators added to genDC and storage information added to storageetap\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_battery_soc_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_battery_soc_process","text":"JPC_battery_soc_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses battery state of charge (SOC) data from a JuliaPowerCase and converts it to JPC format.\n\nThis function extracts battery storage information from the input case and creates two data structures:\n\nA battery SOC matrix containing parameters related to battery energy storage capabilities\nLoad entries in the loadDC matrix to represent battery connections to the power system\n\nFor each battery, the following SOC parameters are stored:\n\nBus ID where the battery is connected\nPower capacity in MW (maximum charge/discharge rate)\nEnergy capacity in MWh\nInitial state of charge (SOC)\nMinimum allowable SOC\nMaximum allowable SOC\nRound-trip efficiency (0.0-1.0)\nStatus indicator (1.0 if in service, 0.0 if not)\n\nAdditionally, for each battery, the function:\n\nCreates a corresponding load entry in the loadDC matrix\nSets the load ID, bus index, and status parameters\nInitializes power values to zero\n\nThe function performs the following steps:\n\nCreates a deep copy of the battery storage data\nIf no batteries exist, returns the JPC object unchanged\nInitializes a matrix to store battery SOC data\nPopulates the SOC matrix with battery parameters\nFor each battery, creates a corresponding load entry in the loadDC matrix\nAdds the processed battery SOC data to the JPC object's storage field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing battery storage data\njpc::JPC: The JPC object where the battery SOC data will be stored\n\nReturns\n\nThe updated JPC object with battery SOC data in the storage field and corresponding load entries in the loadDC field\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_branches_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_branches_process","text":"JPC_branches_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses AC branch data from a JuliaPowerCase and converts it to JPC format.\n\nThis function handles the calculation and conversion of various branch elements  in the power system to the format required by JPC. It processes:\n\nAC transmission lines by calling calculatelineparameters()\nTwo-winding transformers by calling calculatetransformer2wparameters()\n\nThe function is structured to potentially handle different sequence components (positive, negative, zero), though the conditional logic for sequence selection is currently commented out. In its current implementation, it processes only the positive sequence components.\n\nNote: The commented code suggests that for sequence 1 or 2 (positive or negative sequence), the function processes lines and transformers with their standard parameters, while for sequence 0 (zero sequence), it would call a different function (calculatebranchJPC_zero).\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing branch data\njpc::JPC: The JPC object where the processed branch data will be stored\n\nReturns\n\nThe updated JPC object with branch data processed (implicitly, as the jpc object is modified in place)\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_buses_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_buses_process","text":"JPC_buses_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses AC bus data from a JuliaPowerCase and converts it to JPC format.\n\nThis function extracts AC bus information from the input case, transforms it into  the standard matrix format required by JPC, and stores it in the JPC object. Each bus is represented as a row in the matrix with the following columns:\n\nBus ID\nBus type (all initialized as PQ nodes with value 1.0)\nActive power demand (PD) in MW (initialized to 0.0)\nReactive power demand (QD) in MVAR (initialized to 0.0)\nActive power shunt conductance (GS) in MW (initialized to 0.0)\nReactive power shunt susceptance (BS) in MVAR (initialized to 0.0)\nArea ID\nVoltage magnitude (VM) in p.u. (initialized to 1.0)\nVoltage angle (VA) in degrees (initialized to 0.0)\nBase voltage (VN) in kV\nZone ID\nMaximum voltage magnitude in p.u.\nMinimum voltage magnitude in p.u.\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing bus data\njpc::JPC: The JPC object where the processed bus data will be stored\n\nReturns\n\nThe updated JPC object with the busAC field populated\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_dcbranches_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_dcbranches_process","text":"JPC_dcbranches_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses DC branch data from a JuliaPowerCase and converts it to JPC format.\n\nThis function extracts DC branch information from the input case, transforms it into  the standard matrix format required by JPC, and stores it in the JPC object. Each DC branch is represented as a row in the matrix with the following columns:\n\nFrom bus index (F_BUS)\nTo bus index (T_BUS)\nBranch resistance in p.u. (BR_R) - calculated from length and ohms/km\nBranch reactance in p.u. (BR_X) - set to 0 for DC branches\nBranch rating in MVA (RATE_A) - calculated from max current or set to default\nBranch status (BR_STATUS) - 1.0 if in service, 0.0 if not\n\n7-14. Various parameters including angle limits (ANGMIN, ANGMAX)\n\nThe function performs the following steps:\n\nInitializes a matrix to store DC branch data\nFor each DC branch in the case:\nIdentifies the from and to bus indices\nCalculates the base impedance using the from bus base voltage\nConverts resistance from ohms to per unit values\nSets the branch parameters including status and ratings\nSets angle limits to -360° and 360°\nAppends the processed branch data to the JPC object\nProcesses battery branches by calling JPCbatterybranch_process\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing DC branch data\njpc::JPC: The JPC object where the processed DC branch data will be stored\n\nReturns\n\nThe updated JPC object with the branchDC field populated and battery branch data processed\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_dcbuses_process-Tuple{Any, Any}","page":"Utils API","title":"Utils.JPC_dcbuses_process","text":"JPC_dcbuses_process(case::JuliaPowerCase, jpc::JPC)\n\nProcesses DC bus data from a JuliaPowerCase and converts it to JPC format.\n\nThis function extracts DC bus information from the input case, transforms it into  the standard matrix format required by JPC, and stores it in the JPC object. Each DC bus is represented as a row in the matrix with the following columns:\n\nBus ID\nBus type (all initialized as PQ nodes with value 1.0)\nActive power demand (PD) in MW (initialized to 0.0)\nReactive power demand (QD) in MVAR (initialized to 0.0)\nActive power shunt conductance (GS) in MW (initialized to 0.0)\nReactive power shunt susceptance (BS) in MVAR (initialized to 0.0)\nArea ID\nVoltage magnitude (VM) in p.u. (initialized to 1.0)\nVoltage angle (VA) in degrees (initialized to 0.0)\nBase voltage (VN) in kV\nZone ID\nMaximum voltage magnitude in p.u.\nMinimum voltage magnitude in p.u.\n\nAfter processing the basic DC bus data, this function also calls JPCbatterybus_process to handle battery-specific bus information.\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing DC bus data\njpc::JPC: The JPC object where the processed DC bus data will be stored\n\nReturns\n\nThe updated JPC object with the busDC field populated and battery bus data processed\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_dcloads_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_dcloads_process","text":"JPC_dcloads_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess DC load data from a JuliaPowerCase and convert it to JPC format.\n\nThis function extracts information about DC loads from the input case, applies scaling factors, and stores the processed data in the JPC structure. It also updates the power demand values in the corresponding DC bus data.\n\nFor each DC load, the function:\n\nRecords its basic properties (index, bus connection)\nCalculates active power demand with scaling applied\nStores load model composition (ZIP model percentages)\nUpdates the connected DC bus with the additional power demand\n\nThe function performs the following steps:\n\nFilters the input case to identify in-service DC loads\nIf no in-service loads exist, returns without modifications\nCreates a matrix to store DC load data with 8 columns\nFor each DC load:\nPopulates the matrix with all required parameters\nUpdates the corresponding bus data with the load's power demand\nAdds the processed DC load data to the JPC object's loadDC field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing DC load data\njpc::JPC: The JPC object where the processed DC load data will be stored\n\nReturns\n\nThe updated JPC object with DC load data in the loadDC field and updated busDC power demands\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_gens_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_gens_process","text":"JPC_gens_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess generator data from a JuliaPowerCase and convert it to JPC format.\n\nThis function processes three types of generation devices:\n\nExternal grids (typically serving as slack/reference nodes)\nConventional generators (typically serving as PV nodes)\nStatic generators (typically serving as PQ nodes, but can be PV nodes if controllable)\n\nFor each generation device, the function:\n\nExtracts its parameters from the input case\nConverts them to the format required by JPC\nAssigns appropriate bus types based on generator characteristics\nEnsures proper handling of power outputs, limits, and ramp rates\n\nThe function performs the following steps:\n\nCounts the number of each type of generation device\nCreates a matrix to store generator data with 26 columns\nProcesses each type of generator and populates the matrix\nUpdates bus types in the JPC structure based on generator connections\nRemoves entries for out-of-service generators\nEnsures at least one slack node exists in the system\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing generator data\njpc::JPC: The JPC object where the processed generator data will be stored\n\nReturns\n\nNone. The JPC object is modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_inverters_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_inverters_process","text":"JPC_inverters_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess converters/inverters from a JuliaPowerCase and integrate them into the JPC format.\n\nThis function handles the conversion of power electronic converters (inverters) from the  JuliaPowerCase format to the JPC format, updating the relevant bus types and power flow parameters according to each inverter's control mode.\n\nFor each in-service inverter, the function:\n\nDetermines the control mode and sets appropriate flags\nCalculates AC and DC side power flows considering efficiency losses\nUpdates bus types for both AC and DC sides based on control mode\nCreates generator entries when needed for voltage control\nUpdates load records for power injection/consumption\nHandles ZIP load model parameters through weighted averaging\n\nThe function supports the following control modes:\n\nδs_Us: Slack bus on AC side, P node on DC side\nPs_Qs: PQ node on AC side, P node on DC side\nPs_Us: PV node on AC side, P node on DC side\nUdc_Qs: PQ node on AC side, slack node on DC side\nUdc_Us: PV node on AC side, slack node on DC side\nDroopUdcQs: PQ node on AC side with droop control, slack node on DC side\nDroopUdcUs: PV node on AC side with droop control, slack node on DC side\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing converter data\njpc::JPC: The JPC object where the processed converter data will be stored\n\nReturns\n\nThe updated JPC object with converter data integrated into the appropriate fields\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_loads_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_loads_process","text":"JPC_loads_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess AC load data from a JuliaPowerCase and convert it to JPC format.\n\nThis function extracts information about AC loads from the input case, applies scaling factors, and stores the processed data in the JPC structure. It also updates the power demand values in the corresponding AC bus data.\n\nFor each AC load, the function:\n\nRecords its basic properties (index, bus connection)\nCalculates active and reactive power demand with scaling applied\nStores load model composition (ZIP model percentages)\nAccumulates loads connected to the same bus\n\nThe function performs the following steps:\n\nFilters the input case to identify in-service AC loads\nIf no in-service loads exist, returns without modifications\nCreates a matrix to store AC load data with 8 columns\nFor each AC load:\nCalculates actual power demand with scaling applied\nPopulates the matrix with all required parameters\nAccumulates loads by bus connection\nAdds the processed AC load data to the JPC object's loadAC field\nUpdates the busAC matrix with the accumulated load values for each bus\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing AC load data\njpc::JPC: The JPC object where the processed AC load data will be stored\n\nReturns\n\nNone. The JPC object is modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_pv_process-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.JPC_pv_process","text":"JPC_pv_process(case::JuliaPowerCase, jpc::JPC)\n\nProcess photovoltaic (PV) array data from a JuliaPowerCase and convert it to JPC format.\n\nThis function extracts information about PV arrays from the input case, performs necessary calculations to determine their electrical characteristics based on environmental conditions, and stores the processed data in the JPC structure.\n\nFor each PV array, the function:\n\nCalculates key electrical parameters adjusted for environmental conditions:\nOpen-circuit voltage (Voc) adjusted for temperature and series connections\nMaximum power point voltage (Vmpp) adjusted for series-connected panels\nShort-circuit current (Isc) adjusted for temperature, irradiance, and parallel connections\nMaximum power point current (Impp) adjusted for irradiance and parallel-connected panels\nStores all parameters in a standardized matrix format\n\nThe function performs the following steps:\n\nFilters the input case to identify in-service PV arrays\nIf no in-service arrays exist, returns without modifications\nCreates a matrix to store PV array data with 9 columns\nFor each PV array:\nCalculates electrical parameters based on temperature and irradiance conditions\nPopulates the matrix with all required parameters\nAdds the processed PV array data to the JPC object's pv field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing PV array data\njpc::JPC: The JPC object where the processed PV array data will be stored\n\nReturns\n\nThe updated JPC object with PV array data in the pv field\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JuliaPowerCase2Jpc-Tuple{Utils.JuliaPowerCase}","page":"Utils API","title":"Utils.JuliaPowerCase2Jpc","text":"JuliaPowerCase2Jpc(case::Utils.JuliaPowerCase)\n\nConverts a JuliaPowerCase object to a JPC (Julia Power Case) format for power flow analysis.\n\nThis function performs a complete transformation of the power system case data, processing all components and preparing them for power flow calculations. The conversion process includes:\n\nMerging virtual nodes to ensure a proper network topology\nCreating and populating a new JPC object with the following data:\nBasic parameters (base MVA)\nAC buses\nDC buses\nAC branches (lines and transformers)\nDC branches\nAC generators\nBattery systems (as DC generators)\nBattery state of charge data\nAC loads\nDC loads\nPV array data\nInverters (AC/DC converters)\nAC-connected PV systems\n\nArguments\n\ncase::Utils.JuliaPowerCase: The original power system case data\n\nReturns\n\nA fully populated JPC object ready for power flow analysis\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.calculate_line_parameters-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.calculate_line_parameters","text":"JPCbatterysoc_process(case::JuliaPowerCase, jpc::JPC) Processes battery state of charge (SOC) data from a JuliaPowerCase and converts it to JPC format. This function extracts battery storage information from the input case and creates two data structures:\n\nA battery SOC matrix containing parameters related to battery energy storage capabilities Load entries in the loadDC matrix to represent battery connections to the power system\n\nFor each battery, the following SOC parameters are stored:\n\nBus ID where the battery is connected Power capacity in MW (maximum charge/discharge rate) Energy capacity in MWh Initial state of charge (SOC) Minimum allowable SOC Maximum allowable SOC Round-trip efficiency (0.0-1.0) Status indicator (1.0 if in service, 0.0 if not)\n\nAdditionally, for each battery, the function:\n\nCreates a corresponding load entry in the loadDC matrix Sets the load ID, bus index, and status parameters Initializes power values to zero\n\nThe function performs the following steps:\n\nCreates a deep copy of the battery storage data If no batteries exist, returns the JPC object unchanged Initializes a matrix to store battery SOC data Populates the SOC matrix with battery parameters For each battery, creates a corresponding load entry in the loadDC matrix Adds the processed battery SOC data to the JPC object's storage field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing battery storage data jpc::JPC: The JPC object where the battery SOC data will be stored\n\nReturns The updated JPC object with battery SOC data in the storage field and corresponding load entries in the loadDC field\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.calculate_transformer2w_parameters-Tuple{Utils.JuliaPowerCase, Utils.JPC}","page":"Utils API","title":"Utils.calculate_transformer2w_parameters","text":"calculate_transformer2w_parameters(case::JuliaPowerCase, jpc::JPC)\n\nProcesses two-winding transformer data from a JuliaPowerCase and converts it to JPC format.\n\nThis function extracts two-winding transformer information from the input case and creates branch entries in the JPC object to represent transformers in the power system model.\n\nFor each transformer, the following parameters are calculated and stored:\n\nFrom bus (high voltage side) and to bus (low voltage side) indices\nPer-unit resistance and reactance values, adjusted to system base\nShunt susceptance (typically zero for transformers)\nTap ratio and phase shift angle\nPower rating and operational status\nAngle limits\n\nThe function performs the following steps:\n\nExtracts two-winding transformer data from the input case\nIf no transformers exist, returns without modification\nCreates a branch matrix to store transformer parameters\nFor each transformer:\nIdentifies the high and low voltage bus connections\nCalculates impedance parameters based on transformer specifications\nAdjusts values for the system base power\nAccounts for parallel transformers if present\nSets default values for tap ratio, phase shift, and other parameters\nAdds the transformer branch data to the JPC object's branchAC field\n\nArguments\n\ncase::JuliaPowerCase: The original power system case containing transformer data\njpc::JPC: The JPC object where the transformer branch data will be stored\n\nReturns\n\nThe updated JPC object with transformer data added to the branchAC field\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.merge_virtual_nodes-Tuple{Utils.JuliaPowerCase}","page":"Utils API","title":"Utils.merge_virtual_nodes","text":"merge_virtual_nodes(case::JuliaPowerCase)\n\nMerges virtual nodes in a power system case and updates all connected elements.\n\nThis function identifies virtual nodes (nodes with \"_虚拟节点\" in their name),  merges them with their connected real nodes, and updates all references in the system. The process includes:\n\nIdentifying virtual nodes and their connections\nCreating a mapping strategy for node merging\nUpdating all elements (lines, transformers, circuit breakers, loads, generators)\nRemoving virtual nodes and their associated circuit breakers\nMerging loads connected to the same bus after node consolidation\n\nArguments\n\ncase::JuliaPowerCase: The original power system case\n\nReturns\n\nA new JuliaPowerCase with virtual nodes merged and all references updated\n\nNote\n\nVirtual nodes are identified by the substring \"_虚拟节点\" in their names\nAt least two connections are required for a virtual node to be merged\nSelf-loops created during merging are disabled\nLoads at the same bus after merging are consolidated into a single load\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.resolve_node_mapping-Tuple{Any, Any}","page":"Utils API","title":"Utils.resolve_node_mapping","text":"resolve_node_mapping(node_id, node_merge_map)\n\nResolves the final mapping of a node by traversing through a node merge map.\n\nThis function follows the chain of node mappings to find the final destination node. It handles multiple levels of redirection by iteratively looking up each node ID in the mapping until it finds a node that doesn't have a further mapping.\n\nArguments\n\nnode_id: The initial node ID to resolve\nnode_merge_map: A dictionary mapping source nodes to destination nodes\n\nReturns\n\nThe final resolved node ID after following all mappings\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_3ph_add_grid_external_sc_impedance-Tuple{Utils.JuliaPowerCase, Utils.JPC_3ph, Int64}","page":"Utils API","title":"Utils.JPC_3ph_add_grid_external_sc_impedance","text":"JPC_3ph_add_grid_external_sc_impedance(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph, sequence::Int)\n\nAdd external grid short circuit impedance to the appropriate sequence component.\n\nThis function calculates and adds short circuit impedance for external grids to the specified sequence component. For positive sequence (sequence=1), no additional impedance is added. For negative (sequence=2) and zero (sequence=0) sequences, short circuit impedance is added as shunt admittance to the connected buses.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object\nsequence::Int: Sequence component identifier (0=zero, 1=positive, 2=negative)\n\nReturns\n\njpc_3ph::Utils.JPC_3ph: The updated JPC_3ph object\ngs_eg::Vector{Float64}: Conductance values for external grids (only for sequence=2)\nbs_eg::Vector{Float64}: Susceptance values for external grids (only for sequence=2)\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_3ph_branches_process-Tuple{Utils.JuliaPowerCase, Utils.JPC_3ph}","page":"Utils API","title":"Utils.JPC_3ph_branches_process","text":"JPC_3ph_branches_process(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nProcess branch data from a JuliaPowerCase and populate the JPC_3ph object with sequence component branch data.\n\nThis function calculates parameters for lines and transformers for all sequence components (positive, negative, and zero).\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nReturns\n\njpc_3ph::Utils.JPC_3ph: The updated JPC_3ph object with branch data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_3ph_buses_process-Tuple{Utils.JuliaPowerCase, Utils.JPC_3ph}","page":"Utils API","title":"Utils.JPC_3ph_buses_process","text":"JPC_3ph_buses_process(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nProcess bus data from a JuliaPowerCase and populate the JPC_3ph object with sequence component bus data.\n\nThis function creates bus matrices for positive, negative, and zero sequence components. For positive sequence, voltage magnitude is initialized to 1.0 p.u., while for negative and  zero sequence components, voltage magnitude is initialized to 0.0 p.u.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nReturns\n\njpc_3ph::Utils.JPC_3ph: The updated JPC_3ph object with bus data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_3ph_gens_process-Tuple{Utils.JuliaPowerCase, Utils.JPC_3ph}","page":"Utils API","title":"Utils.JPC_3ph_gens_process","text":"JPC_3ph_gens_process(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nProcess generator data from a JuliaPowerCase and populate the JPC_3ph object with sequence component generator data.\n\nThis function handles different types of generators including conventional generators, static generators, and external grids. It also sets appropriate bus types (PQ, PV, or reference) based on the generators.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nSide effects\n\nUpdates jpc_3ph.genAC_1, jpc_3ph.genAC_2, and jpc_3ph.genAC_0 with generator data\nUpdates bus types in jpc_3ph.busAC_1, jpc_3ph.busAC_2, and jpc_3ph.busAC_0\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JPC_3ph_loads_process-Tuple{Utils.JuliaPowerCase, Utils.JPC_3ph}","page":"Utils API","title":"Utils.JPC_3ph_loads_process","text":"JPC_3ph_loads_process(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nProcess load data from a JuliaPowerCase and populate the JPC_3ph object with sequence component load data.\n\nThis function handles different types of loads (wye and delta connected) and distributes their power appropriately across sequence components. For balanced loads, only positive sequence components have non-zero values.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nSide effects\n\nUpdates jpc_3ph.loadAC_1, jpc_3ph.loadAC_2, and jpc_3ph.loadAC_0 with load data\nUpdates PD and QD fields in bus matrices for all sequence components\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.JuliaPowerCase2Jpc_3ph-Tuple{Utils.JuliaPowerCase}","page":"Utils API","title":"Utils.JuliaPowerCase2Jpc_3ph","text":"JuliaPowerCase2Jpc_3ph(case::JuliaPowerCase)\n\nConvert a JuliaPowerCase object to a three-phase JPC_3ph object.\n\nThis function processes a power system case in JuliaPowerCase format and converts it into a three-phase sequence component model (JPC_3ph) for three-phase power flow analysis.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data in JuliaPowerCase format\n\nReturns\n\njpc_3ph::JPC_3ph: The converted three-phase power system model\ngs_eg::Vector{Float64}: Conductance values for external grids\nbs_eg::Vector{Float64}: Susceptance values for external grids\n\nProcess\n\nMerges virtual nodes\nCreates a new JPC_3ph object\nSets base parameters\nProcesses bus data for all sequence components\nProcesses branch data for all sequence components\nProcesses generator data for all sequence components\nProcesses load data for all sequence components\nAdds external grid short circuit impedance data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.add_line_sc_impedance_zero-Tuple{Utils.JuliaPowerCase, Utils.JPC_3ph, Any}","page":"Utils API","title":"Utils.add_line_sc_impedance_zero","text":"add_line_sc_impedance_zero(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph, branch)\n\nAdd zero sequence impedance parameters for lines to the branch matrix.\n\nThis function calculates and adds zero sequence parameters for transmission lines. If specific zero sequence data is not available, it approximates using positive sequence data.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object\nbranch: The branch matrix to be updated with zero sequence parameters\n\nReturns\n\nUpdated branch matrix with zero sequence line parameters\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.add_trafo_sc_impedance_zero-Tuple{Utils.JuliaPowerCase, Utils.JPC_3ph, Any}","page":"Utils API","title":"Utils.add_trafo_sc_impedance_zero","text":"add_trafo_sc_impedance_zero(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph, branch)\n\nAdd zero sequence impedance parameters for transformers to the branch matrix.\n\nThis function calculates and adds zero sequence parameters for two-winding transformers, considering different transformer vector groups (winding connections). For some connections, transformers are represented as shunt admittances rather than branches in the zero sequence network.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object\nbranch: The branch matrix to be updated with zero sequence parameters\n\nReturns\n\nUpdated branch matrix with zero sequence transformer parameters\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.calculate_3ph_line_parameters-Tuple{Utils.JuliaPowerCase, Utils.JPC_3ph}","page":"Utils API","title":"Utils.calculate_3ph_line_parameters","text":"calculate_3ph_line_parameters(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nCalculate line parameters for positive and negative sequence components.\n\nThis function processes line data from a JuliaPowerCase and converts it to JPC format for both positive and negative sequence components. For most lines, negative sequence parameters are equal to positive sequence parameters.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nSide effects\n\nUpdates jpc_3ph.branchAC_1 (positive sequence) and jpc_3ph.branchAC_2 (negative sequence)\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.calculate_3ph_transformer2w_parameters-Tuple{Utils.JuliaPowerCase, Utils.JPC_3ph}","page":"Utils API","title":"Utils.calculate_3ph_transformer2w_parameters","text":"calculate_3ph_transformer2w_parameters(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nCalculate two-winding transformer parameters for positive and negative sequence components.\n\nThis function processes two-winding transformer data from a JuliaPowerCase and converts it to JPC format for both positive and negative sequence components. For most transformers, negative sequence parameters are equal to positive sequence parameters.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nSide effects\n\nUpdates jpc_3ph.branchAC_1 (positive sequence) and jpc_3ph.branchAC_2 (negative sequence)\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.calculate_branch_JPC_zero-Tuple{Utils.JuliaPowerCase, Utils.JPC_3ph}","page":"Utils API","title":"Utils.calculate_branch_JPC_zero","text":"calculate_branch_JPC_zero(case::JuliaPowerCase, jpc_3ph::Utils.JPC_3ph)\n\nCalculate zero sequence branch parameters for lines and transformers.\n\nThis function creates the zero sequence branch matrix and populates it with parameters for lines and transformers. Zero sequence parameters often differ significantly from positive sequence parameters, especially for transformers with different winding connections.\n\nArguments\n\ncase::JuliaPowerCase: The power system case data\njpc_3ph::Utils.JPC_3ph: The three-phase JPC object to be populated\n\nReturns\n\njpc_3ph::Utils.JPC_3ph: The updated JPC_3ph object with zero sequence branch data\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Other-Functions","page":"Utils API","title":"Other Functions","text":"","category":"section"},{"location":"api/utils.html#Utils.extract_islands-Tuple{Utils.JPC}","page":"Utils API","title":"Utils.extract_islands","text":"extract_islands(jpc::JPC)\n\nExtract electrically isolated islands from a power system case.\n\nThis function identifies separate electrical islands in the power system and creates individual JPC objects for each valid island. It also identifies isolated buses that don't belong to any energized island.\n\nArguments\n\njpc::JPC: Power system case data structure\n\nReturns\n\nVector{JPC}: List of JPC objects, each representing an energized island\nVector{Int}: List of isolated buses (buses not connected to any energized island)\n\nNotes\n\nAn island is considered valid/energized if it contains at least one generator or reference bus\nIslands with only PQ buses and no generation are considered isolated\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.extract_islands_acdc-Tuple{Utils.JPC}","page":"Utils API","title":"Utils.extract_islands_acdc","text":"extract_islands_acdc(jpc::JPC)\n\nExtract electrically isolated islands from a hybrid AC-DC power system case.\n\nThis function identifies separate electrical islands in a hybrid AC-DC power system and creates individual JPC objects for each valid island. It handles the complexity of interconnected AC and DC subsystems through converters.\n\nArguments\n\njpc::JPC: Power system case data structure containing both AC and DC components\n\nReturns\n\nVector{JPC}: List of JPC objects, each representing an energized island\nVector{Int}: List of isolated AC buses (buses not connected to any energized island)\n\nNotes\n\nAn island is considered valid/energized if it contains at least one generator, reference bus, or has a power source in its connected DC subsystem\nIslands with only PQ buses and no generation capability are considered isolated\nThe function checks for potential issues like multiple reference nodes or batteries in constant Vdc mode that might cause power flow calculation errors\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.find_islands-Tuple{Utils.JPC}","page":"Utils API","title":"Utils.find_islands","text":"find_islands(jpc::JPC)\n\nFind electrically isolated islands in an AC power system.\n\nThis function identifies connected components in the power network by analyzing the branch connections between buses. It also identifies isolated PQ buses and islands that contain only PQ buses (no generators or reference buses).\n\nArguments\n\njpc::JPC: Power system case data structure\n\nReturns\n\nVector{Vector{Int}}: List of islands (each containing bus IDs)\nVector{Int}: List of isolated buses (PQ buses with no connections)\n\n\n\n\n\n","category":"method"},{"location":"api/utils.html#Utils.find_islands_acdc-Tuple{Utils.JPC}","page":"Utils API","title":"Utils.find_islands_acdc","text":"find_islands_acdc(jpc::JPC)\n\nFind electrically isolated islands in a hybrid AC-DC power system.\n\nThis function extends the island detection to handle both AC and DC subsystems, including converter connections between them. It identifies connected components across the entire network and classifies islands based on their generation capabilities.\n\nArguments\n\njpc::JPC: Power system case data structure containing both AC and DC components\n\nReturns\n\nVector{Vector{Int}}: List of AC islands (each containing bus IDs)\nVector{Int}: List of isolated AC buses (PQ buses with no viable connections)\n\nNotes\n\nIslands with only PQ buses and no generation capability (either directly or through DC connections) are considered isolated\nIf no DC buses exist, the function falls back to the standard AC island detection\n\n\n\n\n\n","category":"method"},{"location":"api/timeseriespowerflow.html#API-Reference","page":"TimeSeriesPowerFlow API","title":"API Reference","text":"","category":"section"},{"location":"api/timeseriespowerflow.html#Input-Interface","page":"TimeSeriesPowerFlow API","title":"Input Interface","text":"","category":"section"},{"location":"api/timeseriespowerflow.html#TimeSeriesPowerFlow.read_irradiance_data-Tuple{Any}","page":"TimeSeriesPowerFlow API","title":"TimeSeriesPowerFlow.read_irradiance_data","text":"read_irradiance_data(file_path)\n\nRead solar irradiance time series data from an Excel file.\n\nArguments\n\nfile_path: Path to the Excel file containing irradiance data\n\nReturns\n\nhour_column: Vector containing hour values from the first column\ntime_str_column: Vector containing time string representations from the second column\ndata: DataFrame containing the entire irradiance dataset\n\nDescription\n\nThis function reads solar irradiance time series data from an Excel file into a DataFrame. It extracts the hour values (first column) and time string representations (second column). The function returns these components separately along with the complete DataFrame for further processing.\n\n\n\n\n\n","category":"method"},{"location":"api/timeseriespowerflow.html#TimeSeriesPowerFlow.read_load_data-Tuple{Any}","page":"TimeSeriesPowerFlow API","title":"TimeSeriesPowerFlow.read_load_data","text":"read_load_data(file_path)\n\nRead load time series data from an Excel file.\n\nArguments\n\nfile_path: Path to the Excel file containing load data\n\nReturns\n\ntime_column: Vector containing time values from the first column\ntime_str_column: Vector containing time string representations from the second column\nload_names: Vector of load names extracted from column headers\ndata: DataFrame containing the entire load dataset\n\nDescription\n\nThis function reads load time series data from an Excel file into a DataFrame. It extracts the time values (first column), time string representations (second column), and the names of the loads from the column headers. The function returns these components separately along with the complete DataFrame for further processing.\n\n\n\n\n\n","category":"method"},{"location":"api/timeseriespowerflow.html#TimeSeriesPowerFlow.read_price_data-Tuple{Any}","page":"TimeSeriesPowerFlow API","title":"TimeSeriesPowerFlow.read_price_data","text":"read_price_data(file_path)\n\nRead electricity price time series data from an Excel file.\n\nArguments\n\nfile_path: Path to the Excel file containing price data\n\nReturns\n\ntime_column: Vector containing time values from the first column\ntime_str_column: Vector containing time string representations from the second column\ndata: DataFrame containing the entire price dataset\n\nDescription\n\nThis function reads electricity price time series data from an Excel file into a DataFrame. It extracts the time values (first column) and time string representations (second column). The function returns these components separately along with the complete DataFrame for further processing.\n\n\n\n\n\n","category":"method"},{"location":"api/timeseriespowerflow.html#TimeSeries-Functions","page":"TimeSeriesPowerFlow API","title":"TimeSeries Functions","text":"","category":"section"},{"location":"api/timeseriespowerflow.html#TimeSeriesPowerFlow.runtdpf-NTuple{6, Any}","page":"TimeSeriesPowerFlow API","title":"TimeSeriesPowerFlow.runtdpf","text":"runtdpf(case, data, load_names, price_profiles, irradiance_profiles, opt)\n\nRun time-domain power flow analysis for multiple days with varying loads, prices, and solar irradiance.\n\nArguments\n\ncase: Power system case data structure\ndata: DataFrame containing load time series data\nload_names: Vector of load names\nprice_profiles: Matrix containing electricity price data\nirradiance_profiles: Matrix containing solar irradiance data\nopt: Options for power flow calculation\n\nReturns\n\n3D array of results where dimensions represent [island, day, hour]\n\nDescription\n\nThis function performs time-domain power flow analysis across multiple days, considering varying loads, electricity prices, and solar irradiance. It processes the data day by day and handles multiple grid islands.\n\nThe function performs the following steps:\n\nDetermines the number of days from the time series data\nValidates that the number of time points is divisible by 24 (hours per day)\nGenerates daily load, price, and irradiance data using helper functions\nConverts the power system case to JPC format\nExtracts grid islands from the power system\nFor each day and each island (in parallel):\nExtracts the relevant load data for the island\nPerforms power flow calculations for each hour using the run_single_day function\nReturns a 3D array of results organized by island, day, and hour\n\nThe parallel processing is implemented using Julia's threading capabilities (@threads), with the outer loop over days being parallelized for efficiency.\n\n\n\n\n\n","category":"method"},{"location":"api/timeseriespowerflow.html#TimeSeriesPowerFlow.build_incidence_matrix_td-NTuple{4, Any}","page":"TimeSeriesPowerFlow API","title":"TimeSeriesPowerFlow.build_incidence_matrix_td","text":"build_incidence_matrix_td(n_nodes, branchAC, branchDC, converter)\n\nBuild the incidence matrix for a hybrid AC-DC power system.\n\nArguments\n\nn_nodes: Total number of nodes in the system\nbranchAC: Matrix containing AC branch data, with columns for from/to buses\nbranchDC: Matrix containing DC branch data, with columns for from/to buses\nconverter: Matrix containing converter data, with columns for AC/DC bus connections\n\nReturns\n\nA: Incidence matrix where rows represent branches and columns represent nodes\nbranch_data: Vector of tuples containing (fromnode, tonode, branchtype, originalindex) where branch_type is 1 for AC branches, 2 for DC branches, and 3 for converters\n\nDescription\n\nThis function constructs the node-branch incidence matrix for a hybrid AC-DC power system. The incidence matrix A has dimensions (nbranches × nnodes) where nbranches is the total number of branches (AC branches + DC branches + converters) and nnodes is the total number of nodes in the system.\n\nFor each branch connecting nodes i and j:\n\nA[branch, i] = 1 (outflow from node i is positive)\nA[branch, j] = -1 (inflow to node j is negative)\n\nThe function also returns branch_data, which provides information about each branch including its start and end nodes, type (AC, DC, or converter), and its original index in the input data. Branches are sorted by their starting node for consistent ordering.\n\n\n\n\n\n","category":"method"},{"location":"api/timeseriespowerflow.html#Visualization","page":"TimeSeriesPowerFlow API","title":"Visualization","text":"","category":"section"},{"location":"api/timeseriespowerflow.html#TimeSeriesPowerFlow.plot_flow_violations","page":"TimeSeriesPowerFlow API","title":"TimeSeriesPowerFlow.plot_flow_violations","text":"plot_flow_violations(results, case, time_day, flow_limit = 3.0, plot_type = \"summary\", flow_direction = \"max\"; save_path = nothing, save_format = \"pdf\")\n\nPlot power flow violations in power system branches.\n\nArguments\n\nresults: Simulation results containing branch flow data\ncase: Power system case data\ntime_day: Number of days in the simulation\nflow_limit: Power flow limit in MW (default: 3.0)\nplot_type: Type of plot to generate:\n\"summary\": Overall statistics of violations\n\"worst\": Shows the worst branches with violations\n\"all\": Shows all branches with violations\nflow_direction: How to evaluate flow violations:\n\"max\": Maximum absolute value of flow in either direction\n\"both\": Same as \"max\"\n\"forward\": Only check flow from from-bus to to-bus\n\"reverse\": Only check flow from to-bus to from-bus\nsave_path: Optional path to save the plot\nsave_format: Format to save the plot (default: \"pdf\")\n\nReturns\n\nplot_result: The generated plot\nviolation_count: Number of branches with violations at each time point\nmax_violation_percent: Maximum violation percentage at each time point\ntotal_violation_severity: Sum of violation severity at each time point\nviolation_details: Detailed information about each violation\nbranch_violation_stats: Statistics for each branch with violations\n\n\n\n\n\n","category":"function"},{"location":"api/timeseriespowerflow.html#TimeSeriesPowerFlow.plot_PD_time_series","page":"TimeSeriesPowerFlow API","title":"TimeSeriesPowerFlow.plot_PD_time_series","text":"Plot the time series of active load Parameters: results - Result dataset busname - Bus name case - System case timeday - Number of days bus_type - Bus type (default is \"AC\")\n\n\n\n\n\n","category":"function"},{"location":"api/timeseriespowerflow.html#Other-Functions","page":"TimeSeriesPowerFlow API","title":"Other Functions","text":"","category":"section"},{"location":"api/timeseriespowerflow.html#TimeSeriesPowerFlow.create_time_series_irradiance","page":"TimeSeriesPowerFlow API","title":"TimeSeriesPowerFlow.create_time_series_irradiance","text":"create_time_series_irradiance(irradiance_profiles, num_days=nothing)\n\nCreate time series solar irradiance data for renewable energy simulation.\n\nArguments\n\nirradiance_profiles: Matrix containing solar irradiance data, where rows represent days and columns represent hours\nnum_days: Optional parameter specifying the number of days to process (defaults to all available days)\n\nReturns\n\nDictionary mapping day number to irradiance matrix for that day\n\nDescription\n\nThis function processes solar irradiance profiles and organizes them into daily irradiance matrices. For each day, it creates a matrix where each row represents a specific hour, with columns: [hour, irradiance]\n\nThe function performs the following steps:\n\nDetermines the total number of days available in the irradiance profiles\nLimits processing to the specified number of days if provided\nFor each day and hour:\nExtracts the irradiance value from the irradiance profiles\nCreates a matrix with hour and irradiance information\nReturns a dictionary where keys are day numbers and values are the corresponding irradiance matrices\n\nThe irradiance profiles are expected to have a structure where the first column contains date information and subsequent columns (2-25) contain hourly irradiance data.\n\n\n\n\n\n","category":"function"},{"location":"api/timeseriespowerflow.html#TimeSeriesPowerFlow.create_time_series_loads-Tuple{Utils.JuliaPowerCase, Any, Any, Any}","page":"TimeSeriesPowerFlow API","title":"TimeSeriesPowerFlow.create_time_series_loads","text":"create_time_series_loads(case::Utils.JuliaPowerCase, data, load_names, num_days)\n\nCreate time series load data for power system simulation based on input data.\n\nArguments\n\ncase: Power system case data structure\ndata: DataFrame containing load time series data\nload_names: Vector of load names\nnum_days: Number of days to process\n\nReturns\n\nDictionary mapping day number to load matrix for that day\n\nDescription\n\nThis function processes time series load data and creates daily load matrices for power system simulation. For each day, it creates a matrix where each row represents a specific bus at a specific hour, with columns: [hour, busid, activepower, reactivepower, constzpercent, constipercent, constp_percent]\n\nThe function performs the following steps:\n\nValidates that the number of time points is divisible by 24 (hours per day)\nFilters in-service loads from the power system case\nMaps load names to column indices in the input data\nFor each day and hour:\nAccumulates loads connected to the same bus\nCalculates actual active and reactive power based on apparent power and power factor\nComputes weighted load characteristics (ZIP model parameters)\nEnsures load characteristic percentages sum to 1\nReturns a dictionary where keys are day numbers and values are the corresponding load matrices\n\nThe function handles cases where load names in the data match or don't match those in the power system case, maintaining power factor and appropriately scaling loads based on the input data.\n\n\n\n\n\n","category":"method"},{"location":"api/timeseriespowerflow.html#TimeSeriesPowerFlow.create_time_series_prices","page":"TimeSeriesPowerFlow API","title":"TimeSeriesPowerFlow.create_time_series_prices","text":"create_time_series_prices(price_profiles, num_days=nothing)\n\nCreate time series price data for power system economic analysis.\n\nArguments\n\nprice_profiles: Matrix containing electricity price data, where rows represent days and columns represent hours\nnum_days: Optional parameter specifying the number of days to process (defaults to all available days)\n\nReturns\n\nDictionary mapping day number to price matrix for that day\n\nDescription\n\nThis function processes electricity price profiles and organizes them into daily price matrices. For each day, it creates a matrix where each row represents a specific hour, with columns: [hour, price]\n\nThe function performs the following steps:\n\nDetermines the total number of days available in the price profiles\nLimits processing to the specified number of days if provided\nFor each day and hour:\nExtracts the price value from the price profiles\nCreates a matrix with hour and price information\nReturns a dictionary where keys are day numbers and values are the corresponding price matrices\n\nThe price profiles are expected to have a structure where the first column contains date information and subsequent columns (2-25) contain hourly price data.\n\n\n\n\n\n","category":"function"},{"location":"api/timeseriespowerflow.html#TimeSeriesPowerFlow.extract_load_matrix_by_islands-Tuple{Any, Any}","page":"TimeSeriesPowerFlow API","title":"TimeSeriesPowerFlow.extract_load_matrix_by_islands","text":"extract_load_matrix_by_islands(day_load_matrix, jpc_list)\n\nExtract and organize load data by power system islands.\n\nArguments\n\nday_load_matrix: Matrix containing load data for a day, where rows represent loads and columns include time, bus ID, and load values\njpc_list: List of power system cases representing different islands in the network\n\nReturns\n\nload_matrix_list: List of load matrices, one for each island\nisolated_load_matrix: Matrix containing load data for buses not belonging to any island\n\nDescription\n\nThis function distributes load data among different power system islands based on bus IDs. It separates the daily load data into distinct matrices for each island in the power system.\n\nThe function performs the following steps:\n\nExtracts bus IDs from the load data matrix (assumed to be in the second column)\nFor each island in the power system:\nIdentifies the AC buses belonging to the island\nFinds load data rows associated with those buses\nCreates a load matrix specific to that island\nIf no loads are found for an island, creates an empty matrix with the same column structure\nIdentifies loads on buses that don't belong to any valid island (isolated buses)\nReturns both the list of island-specific load matrices and the matrix for isolated loads\n\nThis function is essential for distributed power flow analysis where each island  needs to be processed separately with its corresponding load data.\n\n\n\n\n\n","category":"method"},{"location":"index.html#TSPF.jl","page":"Home","title":"TSPF.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Time Series Power Flow Analysis Tool","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"TSPF.jl is a Julia package for distribution system simulation design. It provides AC/DC hybrid power flow calculation and time series power flow calculation functions for power systems that support the access of photovoltaic, energy storage and VSC equipment.","category":"page"},{"location":"index.html#2.-Features","page":"Home","title":"2. Features","text":"","category":"section"},{"location":"index.html#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Complete Components Model: AC system models, DC system models, Hybrid models and carbon emission models, etc.\nComplete case structure: JuliaPowerCase, JPC\nIndependent functional Module: TSPF, Utils, PowerFlow, TimeSeriesPowerFlow\nDOPF Fusion: Using relaxed OPF to bridge time varying loads and generation profiles on the energy status of ESSs\nMulti Control Mode Aggregation: Support 7 VSC control modes\nAggregation of externally input and internally generated studies: Support external input cases and internal generated cases","category":"page"},{"location":"index.html#Project-Structure","page":"Home","title":"Project Structure","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"TSPF.jl contains four main modules:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"TSPF: Power system component modeling\nUtils: General utility functions\nPowerFlow: AC/DC hybrid power flow calculation\nTimeSeriesPowerFlow: Time series power flow analysis","category":"page"},{"location":"index.html#3.-Installation","page":"Home","title":"3. Installation","text":"","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"You can install this package through Julia's package manager:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"TSPF\")","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Or, if you want to use the latest development version:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/Luosipeng/TSPF.jl.git\")","category":"page"},{"location":"index.html#4.-Quick-Start-Example","page":"Home","title":"4. Quick Start Example","text":"","category":"section"},{"location":"index.html#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Here's a simple example showing how to use TSPF.jl to run the time series power flow:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"# Add project path\npush!(LOAD_PATH, \"/path/to/TSPF\")\n\n# Import modules\nusing TSPF\n\nfile_path = joinpath(pwd(), \"data\", \"test_case.xlsx\")\n\ncase = load_julia_power_data(file_path)\n\n# Topology processing\nresults, new_case = topology_analysis(case, output_file=\"topology_results.xlsx\")\n\n# View results\nprintln(\"Found \", nrow(results[\"cycles\"]), \" cycles\")\nprintln(\"Network is divided into \", length(unique(results[\"nodes\"].Partition)), \" partitions\")\n\njpc = JuliaPowerCase2Jpc(new_case)\n\nopt = options() # The initial settings \nopt[\"PF\"][\"NR_ALG\"] = \"bicgstab\";\nopt[\"PF\"][\"ENFORCE_Q_LIMS\"] = 0;\nopt[\"PF\"][\"DC_PREPROCESS\"] = 1;\n\njpc_list, isolated = extract_islands_acdc(jpc)\nn_islands = length(jpc_list)\nprintln(\"Extracted $(n_islands) islands in total\")\n\n# Create results array\nresults_array = Vector{Any}(undef, n_islands)\n\nprintln(\"Starting multi-threaded calculation...\")\nt_start = time()\n\n# Use multi-threading to calculate power flow for each island\n@threads for i in 1:n_islands\n    results_array[i] = runhpf(jpc_list[i], opt)\nend\n\nt_end = time()\nelapsed = t_end - t_start\n\n# Construct result similar to @timed return\nresults = (value=results_array, time=elapsed)\n\n# # Get voltage results for all nodes\nvoltage_results = get_bus_voltage_results_acdc(results, new_case)","category":"page"},{"location":"index.html#5.-Documentation-Structure","page":"Home","title":"5. Documentation Structure","text":"","category":"section"},{"location":"index.html#Documentation-Structure","page":"Home","title":"Documentation Structure","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This documentation is divided into the following sections:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Module: Detailed usage and examples of various modules\nComponentModel: Detailed introduction to ComponentModel.jl\nUtils: Detailed introduction to Utils.jl\nPowerFlow: Detailed introduction to PowerFlow.jl\nTimeSeriesPowerFlow: Detailed introduction to TimeSeriesPowerFlow.jl\nAPI: API document of various modules\nComponentModel API: API document of ComponentModel.jl\nUtils API: API document of Utils.jl\nPowerFlow API: API document of PowerFlow.jl\nTimeSeriesPowerFlow API: API document of TimeSeriesPowerFlow.jl","category":"page"},{"location":"index.html#6.-Contribution-and-License-Information","page":"Home","title":"6. Contribution and License Information","text":"","category":"section"},{"location":"index.html#Contribution","page":"Home","title":"Contribution","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Contributions to TSPF.jl are welcome! Please refer to the Contribution Guidelines for more information.","category":"page"},{"location":"index.html#License","page":"Home","title":"License","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"TSPF.jl is licensed under the MIT License.","category":"page"},{"location":"index.html#7.-Citation-Information","page":"Home","title":"7. Citation Information","text":"","category":"section"},{"location":"index.html#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you use TSPF.jl in your research, please cite:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@misc{TSPF.jl,\n  author = {Luosipeng},\n  title = {TSPF.jl: a Julia package for distribution system dynamic power flow},\n  year = {2023},\n  publisher = {GitHub},\n  url = {https://github.com/Luosipeng/TSPF.jl}\n}","category":"page"},{"location":"api/componentmodel.html#API-Reference","page":"ComponentModel API","title":"API Reference","text":"","category":"section"},{"location":"api/componentmodel.html#AC-Components","page":"ComponentModel API","title":"AC Components","text":"","category":"section"},{"location":"api/componentmodel.html#ComponentModel.Bus","page":"ComponentModel API","title":"ComponentModel.Bus","text":"Bus <: AbstractComponent\n\nStructure representing a bus (node) in power systems.\n\nFields\n\nindex::Int: Unique identifier for the bus\nname::String: Bus name\nvn_kv::Float64: Nominal voltage level in kV\nmax_vm_pu::Float64: Maximum voltage magnitude in per unit\nmin_vm_pu::Float64: Minimum voltage magnitude in per unit\nin_service::Bool: Operating status flag\nbus_id::Int: Bus identifier\narea_id::Int: Area identifier the bus belongs to\nzone_id::Int: Zone identifier the bus belongs to\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.BusDC","page":"ComponentModel API","title":"ComponentModel.BusDC","text":"BusDC <: AbstractComponent\n\nRepresents a DC bus (node) in a power system network.\n\nFields\n\nindex::Int: Unique identifier for the bus\nname::String: Name of the bus\nvn_kv::Float64: Nominal voltage in kilovolts\nmax_vm_pu::Float64: Maximum allowed voltage magnitude in per unit\nmin_vm_pu::Float64: Minimum allowed voltage magnitude in per unit\nin_service::Bool: Operational status (true if in service)\nbus_id::Int: External bus identifier\narea_id::Int: Area identifier the bus belongs to\nzone_id::Int: Zone identifier the bus belongs to\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.ACPVSystem","page":"ComponentModel API","title":"ComponentModel.ACPVSystem","text":"ACPVSystem <: AbstractComponent\n\nStructure representing an AC photovoltaic system, including PV module and inverter parameters.\n\nFields\n\nindex::Int: Unique identifier for the PV system\nname::String: PV system name\nbus::Int: Connected bus number\np_mw::Float64: Active power output (MW)\nq_mvar::Float64: Reactive power output (MVar)\nvm_ac_pu::Float64: AC-side voltage magnitude (per unit)\nvm_dc_pu::Float64: DC-side voltage magnitude (per unit)\nloss_percent::Float64: Loss percentage\nloss_mw::Float64: Power loss (MW)\nmax_p_mw::Float64: Maximum active power limit (MW)\nmin_p_mw::Float64: Minimum active power limit (MW)\nmax_q_mvar::Float64: Maximum reactive power limit (MVar)\nmin_q_mvar::Float64: Minimum reactive power limit (MVar)\nnumpanelseries::Int: Number of panels in series\nnumpanelparallel::Int: Number of panels in parallel\nvmpp::Float64: Maximum power point voltage\nimpp::Float64: Maximum power point current\nvoc::Float64: Open-circuit voltage\nisc::Float64: Short-circuit current\npvanumcells::Int: Number of PV cells\nirradiance::Float64: Irradiance (W/m²)\ntemperature::Float64: Temperature (°C)\nα_isc::Float64: Short-circuit current temperature coefficient\nβ_voc::Float64: Open-circuit voltage temperature coefficient\ncontrol_mode::String: Control mode\ncontrollable::Bool: Controllability flag\nin_service::Bool: Operating status flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.ExternalGrid","page":"ComponentModel API","title":"ComponentModel.ExternalGrid","text":"ExternalGrid <: AbstractComponent\n\nStructure representing an external grid, used for modeling equivalent representations of external power systems.\n\nFields\n\nindex::Int: Unique identifier for the external grid\nname::String: External grid name\nbus::Int: Connected bus number\nvm_pu::Float64: Voltage magnitude (per unit)\nva_degree::Float64: Voltage angle (degrees)\nin_service::Bool: Operating status flag\ns_sc_max_mva::Float64: Maximum short-circuit capacity (MVA)\ns_sc_min_mva::Float64: Minimum short-circuit capacity (MVA)\nrx_max::Float64: Maximum R/X ratio\nrx_min::Float64: Minimum R/X ratio\nr0x0_max::Float64: Maximum zero-sequence R/X ratio\nx0x_max::Float64: Maximum ratio of zero-sequence to positive-sequence reactance\ncontrollable::Bool: Controllability flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.Generator","page":"ComponentModel API","title":"ComponentModel.Generator","text":"Generator <: AbstractComponent\n\nStructure representing a conventional generator unit, including detailed generator parameters and operational characteristics.\n\nFields\n\nindex::Int: Unique identifier for the generator\nname::String: Generator name\nbus::Int: Connected bus number\np_mw::Float64: Active power output (MW)\nvm_pu::Float64: Voltage magnitude (per unit)\nsn_mva::Float64: Rated capacity (MVA)\nscaling::Float64: Power scaling factor\nmax_p_mw::Float64: Maximum active power limit (MW)\nmin_p_mw::Float64: Minimum active power limit (MW)\nmax_q_mvar::Float64: Maximum reactive power limit (MVar)\nmin_q_mvar::Float64: Minimum reactive power limit (MVar)\nvn_kv::Float64: Rated voltage (kV)\nxdss_pu::Float64: Subtransient direct-axis reactance (per unit)\nrdss_pu::Float64: Subtransient resistance (per unit)\ncos_phi::Float64: Power factor\ncontrollable::Bool: Controllability flag\nin_service::Bool: Operating status flag\ntype::String: Generator type\ngenerator_type::String: Generator technology type\nfuel_type::String: Fuel type\nstartup_time_cold_h::Float64: Cold startup time (hours)\nstartup_time_warm_h::Float64: Warm startup time (hours)\nstartup_time_hot_h::Float64: Hot startup time (hours)\nmin_up_time_h::Float64: Minimum up time (hours)\nmin_down_time_h::Float64: Minimum down time (hours)\nramp_up_rate_mw_per_min::Float64: Ramp-up rate (MW/minute)\nramp_down_rate_mw_per_min::Float64: Ramp-down rate (MW/minute)\nefficiency_percent::Float64: Efficiency percentage\nheat_rate_mmbtu_per_mwh::Float64: Heat rate (MMBtu/MWh)\nco2_emission_rate_kg_per_mwh::Float64: CO2 emission rate (kg/MWh)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.StaticGenerator","page":"ComponentModel API","title":"ComponentModel.StaticGenerator","text":"StaticGenerator <: AbstractComponent\n\nStructure representing a static generator, used for modeling simplified generator units.\n\nFields\n\nindex::Int: Unique identifier for the generator\nname::String: Generator name\nbus::Int: Connected bus number\np_mw::Float64: Active power output (MW)\nq_mvar::Float64: Reactive power output (MVar)\nscaling::Float64: Power scaling factor\nmax_p_mw::Float64: Maximum active power limit (MW)\nmin_p_mw::Float64: Minimum active power limit (MW)\nmax_q_mvar::Float64: Maximum reactive power limit (MVar)\nmin_q_mvar::Float64: Minimum reactive power limit (MVar)\nk::Float64: Coefficient k (typically used for control equations)\nrx::Float64: Resistance to reactance ratio\nin_service::Bool: Operating status flag\ntype::String: Generator type (WP-wind power, PV-photovoltaic, CHP-combined heat and power, etc.)\ncontrollable::Bool: Controllability flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.StaticGeneratorDC","page":"ComponentModel API","title":"ComponentModel.StaticGeneratorDC","text":"StaticGeneratorDC <: AbstractComponent\n\nRepresents a static generator in a DC power flow model.\n\nFields\n\nindex::Int: Unique identifier for the generator\nname::String: Name of the generator\nbus::Int: Bus identifier where the generator is connected\np_mw::Float64: Active power output in MW\nscaling::Float64: Scaling factor for the generator output\nmax_p_mw::Float64: Maximum active power output in MW\nmin_p_mw::Float64: Minimum active power output in MW\nk::Float64: Participation factor for power balancing\nrx::Float64: R/X ratio of the generator\nin_service::Bool: Operational status (true if in service)\ntype::String: Generator type (WP-wind power, PV-photovoltaic, CHP-combined heat and power, etc.)\ncontrollable::Bool: Whether the generator output can be controlled\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.StorageAC","page":"ComponentModel API","title":"ComponentModel.StorageAC","text":"StorageAC <: AbstractComponent\n\nStructure representing an AC storage system.\n\nFields\n\nindex::Int: Unique identifier for the storage system\nname::String: Storage system name\nbus::Int: Connected bus number\npower_capacity_mw::Float64: Power capacity (MW)\nenergy_capacity_mwh::Float64: Energy capacity (MWh)\nsoc_init::Float64: Initial state of charge\nmin_soc::Float64: Minimum state of charge\nmax_soc::Float64: Maximum state of charge\nefficiency::Float64: Charging/discharging efficiency\nin_service::Bool: Operating status flag\ntype::String: Storage type\ncontrollable::Bool: Controllability flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.AsymmetricLoad","page":"ComponentModel API","title":"ComponentModel.AsymmetricLoad","text":"AsymmetricLoad <: AbstractComponent\n\nStructure representing an asymmetric load in power systems.\n\nFields\n\nindex::Int: Unique identifier for the load\nname::String: Load name\nbus::Int: Bus number where the load is connected\np_mw::Float64: Active power demand (MW)\nq_mvar::Float64: Reactive power demand (MVAr)\nconst_z_percent::Float64: Percentage of constant impedance load model\nconst_i_percent::Float64: Percentage of constant current load model\nconst_p_percent::Float64: Percentage of constant power load model\nscaling::Float64: Scaling factor for the load\nin_service::Bool: Operating status flag\ntype::String: Load connection type (wye, delta, etc.)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.Load","page":"ComponentModel API","title":"ComponentModel.Load","text":"Load <: AbstractComponent\n\nStructure representing a symmetric load in power systems.\n\nFields\n\nindex::Int: Unique identifier for the load\nname::String: Load name\nbus::Int: Bus number where the load is connected\np_mw::Float64: Active power demand (MW)\nq_mvar::Float64: Reactive power demand (MVAr)\nconst_z_percent::Float64: Percentage of constant impedance load model\nconst_i_percent::Float64: Percentage of constant current load model\nconst_p_percent::Float64: Percentage of constant power load model\nscaling::Float64: Scaling factor for the load\nin_service::Bool: Operating status flag\ntype::String: Load connection type (wye, delta, etc.)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.LoadDC","page":"ComponentModel API","title":"ComponentModel.LoadDC","text":"LoadDC <: AbstractComponent\n\nRepresents a symmetric load model in a DC power flow analysis.\n\nFields\n\nindex::Int: Unique identifier for the load\nname::String: Name of the load\nbus::Int: Bus identifier where the load is connected\np_mw::Float64: Active power consumption in MW\nconst_z_percent::Float64: Percentage of load with constant impedance characteristic\nconst_i_percent::Float64: Percentage of load with constant current characteristic\nconst_p_percent::Float64: Percentage of load with constant power characteristic\nscaling::Float64: Scaling factor for the load\nin_service::Bool: Operational status (true if in service)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.PVArray","page":"ComponentModel API","title":"ComponentModel.PVArray","text":"PVArray <: AbstractComponent\n\nRepresents a photovoltaic array in a power system.\n\nFields\n\nindex::Int: Unique identifier for the PV array\nname::String: Name of the PV array\nbus::Int: Bus identifier where the PV array is connected\nnumpanelseries::Int: Number of panels connected in series\nnumpanelparallel::Int: Number of panel strings connected in parallel\nvmpp::Float64: Voltage at maximum power point in volts\nimpp::Float64: Current at maximum power point in amperes\nvoc::Float64: Open circuit voltage in volts\nisc::Float64: Short circuit current in amperes\npvanumcells::Int: Number of cells in each PV panel\ntemperature::Float64: Operating temperature in degrees Celsius\nirradiance::Float64: Solar irradiance in W/m²\nα_isc::Float64: Temperature coefficient of short circuit current in %/°C\nβ_voc::Float64: Temperature coefficient of open circuit voltage in %/°C\nin_service::Bool: Operational status (true if in service)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.HighVoltageCircuitBreaker","page":"ComponentModel API","title":"ComponentModel.HighVoltageCircuitBreaker","text":"HighVoltageCircuitBreaker <: AbstractComponent\n\nStructure representing high voltage circuit breakers in power systems.\n\nFields\n\nindex::Int: Unique identifier for the circuit breaker\nname::String: Circuit breaker name\nbus_from::Int: Starting bus number\nbus_to::Int: Ending bus number\nelement_type::String: Connected element type (l-line, t-transformer, b-bus)\nelement_id::Int: Connected element identifier\nclosed::Bool: Circuit breaker status (closed/open)\ntype::String: Circuit breaker type (CB-circuit breaker, LS-load switch, DS-disconnector switch)\nz_ohm::Float64: Circuit breaker impedance (Ω)\nin_service::Bool: Operating status flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.Line","page":"ComponentModel API","title":"ComponentModel.Line","text":"Line <: AbstractComponent\n\nStructure representing AC transmission or distribution lines in power systems.\n\nFields\n\nindex::Int: Unique identifier for the line\nname::String: Line name\nfrom_bus::Int: Starting bus number\nto_bus::Int: Ending bus number\nlength_km::Float64: Line length (km)\nr_ohm_per_km::Float64: Positive sequence resistance per kilometer (Ω/km)\nx_ohm_per_km::Float64: Positive sequence reactance per kilometer (Ω/km)\nc_nf_per_km::Float64: Positive sequence capacitance per kilometer (nF/km)\nr0_ohm_per_km::Float64: Zero sequence resistance per kilometer (Ω/km)\nx0_ohm_per_km::Float64: Zero sequence reactance per kilometer (Ω/km)\nc0_nf_per_km::Float64: Zero sequence capacitance per kilometer (nF/km)\ng_us_per_km::Float64: Conductance per kilometer (μS/km)\nmax_i_ka::Float64: Maximum allowable current (kA)\ntype::String: Line type (cs-cable, ol-overhead line)\nmax_loading_percent::Float64: Maximum loading percentage\nparallel::Int: Number of parallel lines\ndf::Float64: Distribution factor\nin_service::Bool: Operating status flag\n\nReliability Parameters\n\nmtbf_hours::Float64: Mean time between failures (hours)\nmttr_hours::Float64: Mean time to repair (hours)\nsw_hours::Float64: Switching operation time (hours)\nrp_hours::Float64: Repair preparation time (hours)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.LineDC","page":"ComponentModel API","title":"ComponentModel.LineDC","text":"LineDC <: AbstractComponent\n\nRepresents a DC transmission line in a power system.\n\nFields\n\nindex::Int: Unique identifier for the line\nname::String: Name of the line\nfrom_bus::Int: Bus identifier where the line starts\nto_bus::Int: Bus identifier where the line ends\nlength_km::Float64: Length of the line in kilometers\nr_ohm_per_km::Float64: Resistance per kilometer in ohms\nx_ohm_per_km::Float64: Reactance per kilometer in ohms\ng_us_per_km::Float64: Conductance per kilometer in microsiemens\nmax_i_ka::Float64: Maximum current capacity in kiloamperes\ntype::String: Type of the line\nmax_loading_percent::Float64: Maximum loading percentage allowed\nparallel::Int: Number of parallel lines\ndf::Float64: Derating factor\nin_service::Bool: Operational status (true if in service)\nmtbf_hours::Float64: Mean time between failures in hours\nmttr_hours::Float64: Mean time to repair in hours\nsw_hours::Float64: Switching time in hours\nrp_hours::Float64: Replacement time in hours\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.Switch","page":"ComponentModel API","title":"ComponentModel.Switch","text":"Switch <: AbstractComponent\n\nStructure representing switching devices in power systems.\n\nFields\n\nindex::Int: Unique identifier for the switch\nname::String: Switch name\nbus_from::Int: Starting bus number\nbus_to::Int: Ending bus number\nelement_type::String: Connected element type (l-line, t-transformer, b-bus)\nelement_id::Int: Connected element identifier\nclosed::Bool: Switch status (closed/open)\ntype::String: Switch type (CB-circuit breaker, LS-load switch, DS-disconnector switch)\nz_ohm::Float64: Switch impedance (Ω)\nin_service::Bool: Operating status flag\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.Transformer2W","page":"ComponentModel API","title":"ComponentModel.Transformer2W","text":"Transformer2W <: AbstractComponent\n\nRepresents a two-winding transformer in power systems.\n\nFields\n\nindex::Int: Unique identifier for the transformer\nname::String: Transformer name\nstd_type::String: Standard type\nhv_bus::Int: High voltage bus number\nlv_bus::Int: Low voltage bus number\nsn_mva::Float64: Rated power (MVA)\nvn_hv_kv::Float64: Rated voltage at HV side (kV)\nvn_lv_kv::Float64: Rated voltage at LV side (kV)\nvk_percent::Float64: Short-circuit impedance in percent\nvkr_percent::Float64: Short-circuit resistance in percent\npfe_kw::Float64: Iron losses (kW)\ni0_percent::Float64: No-load current in percent\nshift_degree::Float64: Phase shift angle in degrees\n\nTap changer parameters\n\ntap_side::String: Tap changer side (hv/lv)\ntap_neutral::Int: Neutral tap position\ntap_min::Int: Minimum tap position\ntap_max::Int: Maximum tap position\ntap_step_percent::Float64: Tap step size in percent\ntap_step_degree::Float64: Tap step angle in degrees\ntap_pos::Int: Current tap position\ntap_phase_shifter::Bool: Whether it's a phase shifter\n\nOther parameters\n\nparallel::Int: Number of parallel transformers\nmax_loading_percent::Float64: Maximum loading in percent\ndf::Float64: Distribution factor\nin_service::Bool: Operating status flag\noltc::Bool: Whether it has on-load tap changer\npower_station_unit::Bool: Whether it's a power station transformer\n\nTechnical parameters\n\nvector_group::String: Vector group\nhv_connection::String: HV side connection type (Y/D)\nlv_connection::String: LV side connection type (Y/D)\nthermal_capacity_mw::Float64: Thermal capacity (MW)\ncooling_type::String: Cooling method\noil_volume_liters::Float64: Oil volume (liters)\nwinding_material::String: Winding material\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.Transformer2Wetap","page":"ComponentModel API","title":"ComponentModel.Transformer2Wetap","text":"Transformer2Wetap <: AbstractComponent\n\nRepresents a two-winding transformer with ETAP parameters.\n\nFields\n\nindex::Int: Unique identifier for the transformer\nname::String: Transformer name\nstd_type::String: Standard type\nhv_bus::Int: High voltage bus number\nlv_bus::Int: Low voltage bus number\nsn_mva::Float64: Rated power (MVA)\nvn_hv_kv::Float64: Rated voltage at HV side (kV)\nvn_lv_kv::Float64: Rated voltage at LV side (kV)\nz_percent::Float64: Impedance in percent\nx_r::Float64: X/R ratio\nz0_percent::Float64: Zero sequence impedance in percent\nx0_r0::Float64: Zero sequence X/R ratio\n\nTap changer parameters\n\ntap_neutral::Int: Neutral tap position\nprim_tap::Float64: Primary side tap\nprim_tap_min::Int: Primary side minimum tap position\nprim_tap_max::Int: Primary side maximum tap position\nsec_tap::Float64: Secondary side tap\nsec_tap_min::Int: Secondary side minimum tap position\nsec_tap_max::Int: Secondary side maximum tap position\nvectororwinding::String: Vector or winding type\nphaseshifthl::Float64: Phase shift angle between HV and LV sides\nphaseshiftps: Phase shifter angle\n\nOther parameters\n\nparallel::Int: Number of parallel transformers\nmax_loading_percent::Float64: Maximum loading in percent\ndf::Float64: Distribution factor\nin_service::Bool: Operating status flag\noltc::Bool: Whether it has on-load tap changer\npower_station_unit::Bool: Whether it's a power station transformer\nvector_group::String: Vector group\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.Transformer3W","page":"ComponentModel API","title":"ComponentModel.Transformer3W","text":"Transformer3W <: AbstractComponent\n\nRepresents a three-winding transformer in power systems.\n\nFields\n\nindex::Int: Unique identifier for the transformer\nname::String: Transformer name\nstd_type::String: Standard type\nhv_bus::Int: High voltage bus number\nmv_bus::Int: Medium voltage bus number\nlv_bus::Int: Low voltage bus number\nsn_hv_mva::Float64: HV side rated power (MVA)\nsn_mv_mva::Float64: MV side rated power (MVA)\nsn_lv_mva::Float64: LV side rated power (MVA)\nvn_hv_kv::Float64: Rated voltage at HV side (kV)\nvn_mv_kv::Float64: Rated voltage at MV side (kV)\nvn_lv_kv::Float64: Rated voltage at LV side (kV)\nvk_hv_percent::Float64: HV side short-circuit impedance in percent\nvk_mv_percent::Float64: MV side short-circuit impedance in percent\nvk_lv_percent::Float64: LV side short-circuit impedance in percent\nvkr_hv_percent::Float64: HV side short-circuit resistance in percent\nvkr_mv_percent::Float64: MV side short-circuit resistance in percent\nvkr_lv_percent::Float64: LV side short-circuit resistance in percent\npfe_kw::Float64: Iron losses (kW)\ni0_percent::Float64: No-load current in percent\nshift_mv_degree::Float64: MV side phase shift angle in degrees\nshift_lv_degree::Float64: LV side phase shift angle in degrees\n\nTap changer parameters\n\ntap_side::String: Tap changer side (hv/mv/lv)\ntap_neutral::Int: Neutral tap position\ntap_min::Int: Minimum tap position\ntap_max::Int: Maximum tap position\ntap_step_percent::Float64: Tap step size in percent\ntap_step_degree::Float64: Tap step angle in degrees\ntap_at_star_point::Bool: Whether tap changer is at star point\ntap_pos::Int: Current tap position\n\nOther parameters\n\nin_service::Bool: Operating status flag\n\nTechnical parameters\n\nvector_group_hv_mv::String: HV-MV vector group\nvector_group_hv_lv::String: HV-LV vector group\nvector_group_mv_lv::String: MV-LV vector group\nhv_connection::String: HV side connection type (Y/D)\nmv_connection::String: MV side connection type (Y/D)\nlv_connection::String: LV side connection type (Y/D)\nthermal_capacity_mw::Float64: Thermal capacity (MW)\ncooling_type::String: Cooling method\noil_volume_liters::Float64: Oil volume (liters)\nwinding_material::String: Winding material\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#DC-Components","page":"ComponentModel API","title":"DC Components","text":"","category":"section"},{"location":"api/componentmodel.html#ComponentModel.MobileStorage","page":"ComponentModel API","title":"ComponentModel.MobileStorage","text":"MobileStorage <: AbstractComponent\n\nRepresents a mobile energy storage system that can be relocated within a power network.\n\nFields\n\nindex::Int: Unique identifier for the mobile storage system\nname::String: Name of the mobile storage system\ntype::String: Type of mobile storage (container, trailer, truck, ship)\ncapacity_mwh::Float64: Energy storage capacity in MWh\npower_mw::Float64: Maximum power capacity in MW\nsoc_percent::Float64: Current state of charge as a percentage (0-100)\ncharge_efficiency_percent::Float64: Charging efficiency as a percentage (0-100)\ndischarge_efficiency_percent::Float64: Discharging efficiency as a percentage (0-100)\nowner::String: Owner or operator of the mobile storage system\navailability::Float64: Availability factor (0-1)\ncurrent_location::String: Current physical location of the mobile storage\nstatus::String: Current operational status (available, in_transit, connected, maintenance)\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.Storage","page":"ComponentModel API","title":"ComponentModel.Storage","text":"Storage <: AbstractComponent\n\nRepresents a stationary energy storage system in a power network.\n\nFields\n\nindex::Int: Unique identifier for the storage system\nname::String: Name of the storage system\nbus::Int: Bus identifier where the storage system is connected\npower_capacity_mw::Float64: Maximum power capacity in MW\nenergy_capacity_mwh::Float64: Energy storage capacity in MWh\nsoc_init::Float64: Initial state of charge (0-1)\nmin_soc::Float64: Minimum allowed state of charge (0-1)\nmax_soc::Float64: Maximum allowed state of charge (0-1)\nefficiency::Float64: Round-trip efficiency of the storage system (0-1)\nin_service::Bool: Operational status (true if in service)\ntype::String: Type of storage technology (e.g., \"battery\", \"pumped_hydro\")\ncontrollable::Bool: Whether the storage system can be controlled externally\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.Storageetap","page":"ComponentModel API","title":"ComponentModel.Storageetap","text":"Storageetap <: AbstractComponent\n\nRepresents a detailed electrochemical energy storage model with electrical and thermal parameters.\n\nFields\n\nindex::Int: Unique identifier for the storage system\nname::String: Name of the storage system\nbus::Int: Bus identifier where the storage system is connected\nra::Float64: Internal resistance in ohms\ncell::Float64: Number of cells in series per string\nstr::Float64: Number of strings in parallel\npackage::Float64: Number of packages in parallel\nvoc::Float64: Open circuit voltage in volts\nin_service::Bool: Operational status (true if in service)\ntype::String: Type of storage technology\ncontrollable::Bool: Whether the storage system can be controlled externally\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#Hybrid-Components","page":"ComponentModel API","title":"Hybrid Components","text":"","category":"section"},{"location":"api/componentmodel.html#ComponentModel.Converter","page":"ComponentModel API","title":"ComponentModel.Converter","text":"Converter Structure\n\nRepresents a power converter that connects AC and DC systems, with control capabilities\nand operational parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.Charger","page":"ComponentModel API","title":"ComponentModel.Charger","text":"Charger Structure\n\nRepresents an individual charging unit within a charging station, with specific power\ncapabilities and connector types.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.ChargingStation","page":"ComponentModel API","title":"ComponentModel.ChargingStation","text":"ChargingStation Structure\n\nRepresents an electric vehicle charging station with multiple chargers and connection\nto the power system at a specific bus.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.EVAggregator","page":"ComponentModel API","title":"ComponentModel.EVAggregator","text":"EVAggregator Structure\n\nRepresents an entity that aggregates multiple electric vehicles to provide\ngrid services and manage charging/discharging operations collectively.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.V2GService","page":"ComponentModel API","title":"ComponentModel.V2GService","text":"V2GService Structure\n\nRepresents a vehicle-to-grid service provided by an aggregator, including\nservice type, time period, capacity, and pricing information.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.Microgrid","page":"ComponentModel API","title":"ComponentModel.Microgrid","text":"Microgrid Structure\n\nRepresents a microgrid with generation, storage, and load resources that can\noperate connected to or isolated from the main grid.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.FlexLoad","page":"ComponentModel API","title":"ComponentModel.FlexLoad","text":"FlexLoad Structure\n\nRepresents a flexible load that can adjust its consumption pattern\nin response to grid signals or price incentives.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.VirtualPowerPlant","page":"ComponentModel API","title":"ComponentModel.VirtualPowerPlant","text":"VirtualPowerPlant Structure\n\nRepresents a virtual power plant that aggregates distributed energy resources\nto provide grid services and operate as a single controllable entity.\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#Carbon-Components","page":"ComponentModel API","title":"Carbon Components","text":"","category":"section"},{"location":"api/componentmodel.html#ComponentModel.CarbonScenario","page":"ComponentModel API","title":"ComponentModel.CarbonScenario","text":"CarbonScenario <: AbstractComponent\n\nRepresents a carbon emission scenario for power system analysis.\n\nFields\n\nindex::Int: Unique identifier for the scenario\nname::String: Scenario name\ndescription::String: Detailed description of the scenario\nyear::Int: Target year for the scenario\ngrid_carbon_intensity_kgCO2e_per_MWh::Float64: Average grid carbon intensity in kg CO2 equivalent per MWh\nrenewable_penetration_percent::Float64: Percentage of renewable energy penetration\nev_adoption_percent::Float64: Percentage of electric vehicle adoption\nstorage_adoption_percent::Float64: Percentage of energy storage adoption\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.CarbonTimeSeries","page":"ComponentModel API","title":"ComponentModel.CarbonTimeSeries","text":"CarbonTimeSeries <: AbstractComponent\n\nRepresents a time series of carbon emission data in power systems.\n\nFields\n\nindex::Int: Unique identifier for the time series record\ntimestamp::DateTime: Time point of the carbon emission data\ngrid_carbon_intensity_kgCO2e_per_MWh::Float64: Grid carbon intensity in kg CO2 equivalent per MWh\nrenewable_generation_carbon_intensity_kgCO2e_per_MWh::Float64: Carbon intensity of renewable generation in kg CO2 equivalent per MWh\nstorage_carbon_intensity_kgCO2e_per_MWh::Float64: Carbon intensity of energy storage in kg CO2 equivalent per MWh\n\n\n\n\n\n","category":"type"},{"location":"api/componentmodel.html#ComponentModel.EquipmentCarbon","page":"ComponentModel API","title":"ComponentModel.EquipmentCarbon","text":"EquipmentCarbon <: AbstractComponent\n\nRepresents carbon emission data for power system equipment.\n\nFields\n\nindex::Int: Unique identifier for the equipment carbon record\nelement_type::String: Type of equipment (e.g., \"transformer\", \"line\", \"generator\")\nelement_id::Int: Identifier of the specific equipment\ncarbon_embodied_kgCO2e::Float64: Embodied carbon in the equipment in kg CO2 equivalent\ncarbon_operational_kgCO2e_per_year::Float64: Annual operational carbon emissions in kg CO2 equivalent per year\nlifetime_years::Int: Expected lifetime of the equipment in years\nmanufacturing_date::Date: Date when the equipment was manufactured\ninstallation_date::Date: Date when the equipment was installed\nrecycling_rate_percent::Float64: Percentage of materials that can be recycled at end of life\n\n\n\n\n\n","category":"type"},{"location":"api/tspf.html#API-Reference","page":"TSPF API","title":"API Reference","text":"","category":"section"},{"location":"api/tspf.html#TSPF.TSPF","page":"TSPF API","title":"TSPF.TSPF","text":"TSPF\n\nTime Series Power Flow module for power system analysis.\n\n\n\n\n\n","category":"module"},{"location":"api/tspf.html#Core-Module","page":"TSPF API","title":"Core Module","text":"","category":"section"}]
}
